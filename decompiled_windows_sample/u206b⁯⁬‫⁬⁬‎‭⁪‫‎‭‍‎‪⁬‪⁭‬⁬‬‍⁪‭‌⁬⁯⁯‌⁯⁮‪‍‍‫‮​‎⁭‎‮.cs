using SDRSharp.Tetra;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Windows.Forms;

// ⁫⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮
internal static class u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮
{
	// ⁫‭‍⁯⁫‪‭⁭‎‏‎‮​⁯‌⁬‭‮‭‮‌⁬⁫‫‪⁬‭⁫‭⁬⁪⁯‫⁭‎⁬⁬‎⁪⁯‮
	public static bool u206b‭‍⁯⁫‪‭⁭‎‏‎‮​⁯‌⁬‭‮‭‮‌⁬⁫‫‪⁬‭⁫‭⁬⁪⁯‫⁭‎⁬⁬‎⁪⁯‮;

	// ​‍‎⁭‏‏‫⁫‬‫⁫⁬⁬⁬‫⁭⁪‫‭⁯‍‫‌⁮‪‎⁬‪⁭‍⁫‭‎⁭‌​‍‏‌‎‮
	public static bool u200b‍‎⁭‏‏‫⁫‬‫⁫⁬⁬⁬‫⁭⁪‫‭⁯‍‫‌⁮‪‎⁬‪⁭‍⁫‭‎⁭‌​‍‏‌‎‮;

	// ⁭‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮
	private static int u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮;

	// ‭​⁮‪‬‭⁭⁫‭‬⁬‪⁪‍‏‍‌‪⁭‏‮‏‮​⁪‏‪⁮‎‮⁬‏‭⁫‪‬⁮‌⁪⁫‮
	private static int u202d​⁮‪‬‭⁭⁫‭‬⁬‪⁪‍‏‍‌‪⁭‏‮‏‮​⁪‏‪⁮‎‮⁬‏‭⁫‪‬⁮‌⁪⁫‮;

	// ‎‮⁯‫⁫‎‎‭⁭⁪‌‪⁪‪⁭‎‬‏‬‌‭‬‌⁪​‪‏‍‮⁪⁪‎⁮‫‫⁪‫‏⁬‎‮
	public static int u200e‮⁯‫⁫‎‎‭⁭⁪‌‪⁪‪⁭‎‬‏‬‌‭‬‌⁪​‪‏‍‮⁪⁪‎⁮‫‫⁪‫‏⁬‎‮(LogicChannel , int , Rules[] , Dictionary<GlobalNames, int> )
	{
		// 
		// Current member / type: System.Int32 ⁫⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮::‎‮⁯‫⁫‎‎‭⁭⁪‌‪⁪‪⁭‎‬‏‬‌‭‬‌⁪​‪‏‍‮⁪⁪‎⁮‫‫⁪‫‏⁬‎‮(SDRSharp.Tetra.LogicChannel,System.Int32,SDRSharp.Tetra.Rules[],System.Collections.Generic.Dictionary`2<SDRSharp.Tetra.GlobalNames,System.Int32>)
		// File path: C:\SDRSharp\Plugins\Tetra\SDRSharp.Tetra.dll
		// 
		// Product version: 0.0.0.0
		// Exception in: System.Int32 ‎‮⁯‫⁫‎‎‭⁭⁪‌‪⁪‪⁭‎‬‏‬‌‭‬‌⁪​‪‏‍‮⁪⁪‎⁮‫‫⁪‫‏⁬‎‮(SDRSharp.Tetra.LogicChannel,System.Int32,SDRSharp.Tetra.Rules[],System.Collections.Generic.Dictionary<SDRSharp.Tetra.GlobalNames,System.Int32>)
		// 
		// Not supported type System.Object.
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetTypeIndex(TypeDefinition type) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 684
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetContainingType(TypeDefinition leftType, TypeDefinition rightType) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 608
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 492
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.get_ExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 414
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddAssignmentCastIfNeeded(Expression expr) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 112
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.FixAssignmentInList(IList`1 expressionList, Expression value) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 75
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddCasts() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 38
		//    at Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.Process(DecompilationContext theContext, BlockStatement body) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\ExpressionDecompilerStep.cs:line 68
		//    at Telerik.JustDecompiler.Decompiler.DecompilationPipeline.RunInternal(MethodBody body, BlockStatement block, ILanguage language) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\DecompilationPipeline.cs:line 100
		//    at Telerik.JustDecompiler.Decompiler.WriterContextServices.BaseWriterContextService.DecompileMethod(ILanguage language, MethodDefinition method, TypeSpecificContext typeContext) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\WriterContextServices\BaseWriterContextService.cs:line 133
		// 
		// mailto: JustDecompilePublicFeedback@telerik.com

	}

	// ⁬‭‮​⁯‮‬‏​‪‎⁭​‏⁫⁮⁫⁮‎⁭‭⁫‍⁫‪‫⁬⁪‌‫‌‎‮⁯⁬⁮⁪‭‎‬‮
	public static long u206c‭‮​⁯‮‬‏​‪‎⁭​‏⁫⁮⁫⁮‎⁭‭⁫‍⁫‪‫⁬⁪‌‫‌‎‮⁯⁬⁮⁪‭‎‬‮(bool flag, int num, int num = 0, int num = 0)
	{
		long num1 = 0L;
		int num2 = 0;
		int num3;
		if (!flag)
		{
			goto Label0;
		}
	Label1:
		num3 = 109055646;
	Label5:
		while (true)
		{
			int num4 = num3 ^ 109833997;
			uint num5 = (uint)num4;
			switch (num4 % 12)
			{
				case 0:
				{
				Label2:
					num1 += (long)6250;
					num3 = 780400805;
					continue;
				}
				case 1:
				{
					num2 = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d​⁮‪‬‭⁭⁫‭‬⁬‪⁪‍‏‍‌‪⁭‏‮‏‮​⁪‏‪⁮‎‮⁬‏‭⁫‪‬⁮‌⁪⁫‮;
					num3 = (int)(num5 * -1563972974 ^ 236450984);
					continue;
				}
				case 2:
				{
				Label4:
					num1 += (long)12500;
					num3 = 481253935;
					continue;
				}
				case 3:
				{
					switch (num2)
					{
						case 0:
						{
							break;
						}
						case 1:
						{
							goto Label2;
						}
						case 2:
						{
							goto Label3;
						}
						case 3:
						{
							goto Label4;
						}
						default:
						{
							num3 = (int)(num5 * 1671785659 ^ 394764380);
							continue;
						}
					}
					break;
				}
				case 4:
				{
					num3 = (int)(num5 * 1814542669 ^ -1785494693);
					continue;
				}
				case 5:
				{
					u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d​⁮‪‬‭⁭⁫‭‬⁬‪⁪‍‏‍‌‪⁭‏‮‏‮​⁪‏‪⁮‎‮⁬‏‭⁫‪‬⁮‌⁪⁫‮ = num;
					num3 = (int)(num5 * 1936629232 ^ -1251694049);
					continue;
				}
				case 6:
				{
					goto Label0;
				}
				case 7:
				{
					goto Label1;
				}
				case 8:
				{
					num3 = (int)(num5 * -158170853 ^ 641301655);
					continue;
				}
				case 9:
				{
				Label3:
					num1 -= (long)6250;
					num3 = 481253935;
					continue;
				}
				case 11:
				{
					u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮ = num;
					num3 = (int)(num5 * -1745494784 ^ -2032664472);
					continue;
				}
			}
		}
		return num1;
	Label0:
		num1 = (long)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮ * (long)100000000 + (long)num * (long)25000;
		num3 = 1432096560;
		goto Label5;
	}

	// ‫‌⁯‍‪‭⁫‮⁭‪‍‪⁮⁭⁮‮‌‮‏‏⁮⁫‌‪‫⁪‪‌⁫⁯⁬⁯‮​‪‬‬‏‍‮
	public static int u202b‌⁯‍‪‭⁫‮⁭‪‍‪⁮⁭⁮‮‌‮‏‏⁮⁫‌‪‫⁪‪‌⁫⁯⁬⁯‮​‪‬‬‏‍‮(long num)
	{
		int num1;
		switch (u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d​⁮‪‬‭⁭⁫‭‬⁬‪⁪‍‏‍‌‪⁭‏‮‏‮​⁪‏‪⁮‎‮⁬‏‭⁫‪‬⁮‌⁪⁫‮)
		{
			case 0:
			{
				return (int)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d‭‍⁯​‏​‎⁪‏‌⁪‪‭‏⁪‬‏‬⁭⁬⁫⁭‫⁫‮‬⁭‌⁫⁬⁭⁮⁪⁭⁮⁫‎⁮‪‮(num - (long)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮ * (long)100000000 / new decimal(25000));
			}
			case 1:
			{
				goto Label1;
			}
			case 2:
			{
				goto Label2;
			}
			case 3:
			{
				goto Label3;
			}
		}
	Label4:
		num1 = -766278109;
	Label6:
		while (true)
		{
			int num2 = num1 ^ -1439803963;
			uint num3 = (uint)num2;
			switch (num2 % 8)
			{
				case 0:
				{
					goto Label4;
				}
				case 1:
				{
					num1 = (int)(num3 * -945331968 ^ 1398560102);
					continue;
				}
				case 2:
				{
					break;
				}
				case 3:
				{
					return (int)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d‭‍⁯​‏​‎⁪‏‌⁪‪‭‏⁪‬‏‬⁭⁬⁫⁭‫⁫‮‬⁭‌⁫⁬⁭⁮⁪⁭⁮⁫‎⁮‪‮(num - (long)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮ * (long)100000000 / new decimal(25000));
				}
				case 4:
				{
					num1 = (int)(num3 * 485572479 ^ -984314510);
					continue;
				}
				case 5:
				{
					goto Label3;
				}
				case 6:
				{
					num1 = (int)(num3 * -1063126610 ^ -831395790);
					continue;
				}
				case 7:
				{
					goto Label2;
				}
				default:
				{
					return (int)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d‭‍⁯​‏​‎⁪‏‌⁪‪‭‏⁪‬‏‬⁭⁬⁫⁭‫⁫‮‬⁭‌⁫⁬⁭⁮⁪⁭⁮⁫‎⁮‪‮(num - (long)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮ * (long)100000000 / new decimal(25000));
				}
			}
		}
	Label1:
		num -= (long)6250;
		num1 = -1745628572;
		goto Label6;
		return (int)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d‭‍⁯​‏​‎⁪‏‌⁪‪‭‏⁪‬‏‬⁭⁬⁫⁭‫⁫‮‬⁭‌⁫⁬⁭⁮⁪⁭⁮⁫‎⁮‪‮(num - (long)u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u206d‪⁪‎⁬⁪‭​‮⁫⁬⁪⁫‮⁯⁪⁮⁬⁭⁮​⁪‎​​‍⁮​‎‌‭⁯‭‏‏‬‫‪⁬⁬‮ * (long)100000000 / new decimal(25000));
	Label2:
		num += (long)6250;
		num1 = -2021333719;
		goto Label6;
	Label3:
		num -= (long)12500;
		num1 = -1036561306;
		goto Label6;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	// ‎​​⁬‌⁪‏⁫‮⁮⁬‮⁯‪⁪‏⁮⁫‪‌‎‭‮⁪‏‏‪‌‌‌‎⁯​‬‌‬⁭⁭​‫‮
	private static bool u200e​​⁬‌⁪‏⁫‮⁮⁬‮⁯‪⁪‏⁮⁫‪‌‎‭‮⁪‏‏‪‌‌‌‎⁯​‬‌‬⁭⁭​‫‮(LogicChannel , string , string )
	{
		// 
		// Current member / type: System.Boolean ⁫⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮::‎​​⁬‌⁪‏⁫‮⁮⁬‮⁯‪⁪‏⁮⁫‪‌‎‭‮⁪‏‏‪‌‌‌‎⁯​‬‌‬⁭⁭​‫‮(SDRSharp.Tetra.LogicChannel,System.String,System.String)
		// File path: C:\SDRSharp\Plugins\Tetra\SDRSharp.Tetra.dll
		// 
		// Product version: 0.0.0.0
		// Exception in: System.Boolean ‎​​⁬‌⁪‏⁫‮⁮⁬‮⁯‪⁪‏⁮⁫‪‌‎‭‮⁪‏‏‪‌‌‌‎⁯​‬‌‬⁭⁭​‫‮(SDRSharp.Tetra.LogicChannel,System.String,System.String)
		// 
		// Not supported type System.Object.
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetTypeIndex(TypeDefinition type) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 684
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetContainingType(TypeDefinition leftType, TypeDefinition rightType) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 608
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 492
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.get_ExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 414
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddAssignmentCastIfNeeded(Expression expr) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 112
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.FixAssignmentInList(IList`1 expressionList, Expression value) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 75
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddCasts() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 38
		//    at Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.Process(DecompilationContext theContext, BlockStatement body) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\ExpressionDecompilerStep.cs:line 68
		//    at Telerik.JustDecompiler.Decompiler.DecompilationPipeline.RunInternal(MethodBody body, BlockStatement block, ILanguage language) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\DecompilationPipeline.cs:line 100
		//    at Telerik.JustDecompiler.Decompiler.WriterContextServices.BaseWriterContextService.DecompileMethod(ILanguage language, MethodDefinition method, TypeSpecificContext typeContext) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\WriterContextServices\BaseWriterContextService.cs:line 133
		// 
		// mailto: JustDecompilePublicFeedback@telerik.com

	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	// ‎​​⁬‌⁪‏⁫‮⁮⁬‮⁯‪⁪‏⁮⁫‪‌‎‭‮⁪‏‏‪‌‌‌‎⁯​‬‌‬⁭⁭​‫‮
	private static bool u200e​​⁬‌⁪‏⁫‮⁮⁬‮⁯‪⁪‏⁮⁫‪‌‎‭‮⁪‏‏‪‌‌‌‎⁯​‬‌‬⁭⁭​‫‮(string str, string str)
	{
		bool flag = false;
		uint num;
		try
		{
			string str1 = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u200f‫​⁪‎⁪⁮‌⁯⁪⁯⁮‌‬‏‌‭⁯⁯‍⁪‬‫‌‏‭‫‏​‍​‫⁫‎⁭⁭‫⁭⁭‭‮(u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202e‪​⁪⁮⁫‬‪⁭⁪‫‍⁮​‎⁬⁫​⁮⁪⁭‮‌⁬‮‬⁭‫​⁮‭‭‪‫⁮‭‮‎‬⁮‮());
			string str2 = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d​‍​‮‪‍‏⁮‏‏⁮‏‪⁬⁬⁯‌‮‎‫‌‭‫‏‪​‮‫​‬⁯⁭⁯‌⁬‮‮‏‭‮(u003cModuleu003e.u200e‏‌‬⁮‪‭⁭‭⁭‎​‏‌‭‭‭⁭⁬⁯⁫‍‮‫⁯‌‮‏​‬⁫⁯⁮⁫‮‪⁫‬⁮⁬‮<string>(-495434413), u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮());
		Label0:
			int num1 = -1668145495;
			while (true)
			{
				int num2 = num1 ^ -570447179;
				num = (uint)num2;
				switch (num2 % 3)
				{
					case 0:
					{
						goto Label0;
					}
					case 1:
					{
						string[] strArrays = new string[] { str1, u003cModuleu003e.u202a‮‫‏‫‬‬‪⁫⁬​‏⁫⁭‍‪‪‎⁬​‪​‌⁮‮‌​⁫​⁬‪‫⁪⁯⁪‎‫⁭‎⁪‮<string>(-1861052309), str, u003cModuleu003e.u200f⁫‌​⁬‌‎‎‏‍‍⁫‎​‌‬⁯‬‫‭‎‏​‌​⁪‭‬⁬‮⁬​‌⁬⁪‫‫‎⁪⁮‮<string>(-2133888115), null, null };
						DateTime now = DateTime.Now;
						strArrays[4] = now.ToString(u003cModuleu003e.u202a‮‫‏‫‬‬‪⁫⁬​‏⁫⁭‍‪‪‎⁬​‪​‌⁮‮‌​⁫​⁬‪‫⁪⁯⁪‎‫⁭‎⁪‮<string>(-2018936314));
						strArrays[5] = u003cModuleu003e.u206f⁮​‌‪‮‎‭‏‮‎⁮⁮‮⁬⁫‍‍⁪‍⁫⁮‏​‎⁬⁯⁪‪‍⁪⁮‎⁬⁪⁫​⁮⁪⁮‮<string>(2094881554);
						string str3 = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202c‎‎‮⁬‭‬‌‫‍⁫‮⁯‬‭‭⁮​⁭⁪⁬⁯⁮‭⁪‏⁪⁭⁪⁬⁭⁬‬‎‏‬‏‪‌‌‮(strArrays);
						string[] strArrays1 = new string[1];
						string[] strArrays2 = new string[] { str2, null, null, null, null, null, null, null };
						now = DateTime.Now;
						strArrays2[1] = now.ToString(u003cModuleu003e.u202a‮‫‏‫‬‬‪⁫⁬​‏⁫⁭‍‪‪‎⁬​‪​‌⁮‮‌​⁫​⁬‪‫⁪⁯⁪‎‫⁭‎⁪‮<string>(2016894343));
						strArrays2[2] = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮();
						strArrays2[3] = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮();
						strArrays2[4] = str;
						strArrays2[5] = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮();
						strArrays2[6] = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202d⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮();
						strArrays2[7] = str2;
						strArrays1[0] = u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202c‎‎‮⁬‭‬‌‫‍⁫‮⁯‬‭‭⁮​⁭⁪⁬⁯⁮‭⁪‏⁪⁭⁪⁬⁭⁬‬‎‏‬‏‪‌‌‮(strArrays2);
						u206b⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮.u202a⁯‫⁯‭‬‬⁯‫​‏‏‌⁫‫‬⁭⁭​⁫‬⁯⁮⁫‌⁫⁫‪‮‬‏‭‍⁭​⁪‬‌⁭⁮‮(str3, strArrays1);
						flag = true;
						num1 = -457066494;
						continue;
					}
					case 2:
					{
						goto Label1;
					}
				}
			}
		Label1:
		}
		catch
		{
		Label2:
			int num3 = -585840994;
			while (true)
			{
				int num4 = num3 ^ -570447179;
				num = (uint)num4;
				switch (num4 % 3)
				{
					case 0:
					{
						goto Label2;
					}
					case 1:
					{
						goto Label3;
					}
					case 2:
					{
						flag = false;
						num3 = (int)(num * -1109199824 ^ 242036546);
						continue;
					}
				}
			}
		Label3:
		}
		return flag;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	// ​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮
	public static void u200b‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(LogicChannel , Exception , string , string , Dictionary<GlobalNames, int> )
	{
		// 
		// Current member / type: System.Void ⁫⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮::​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(SDRSharp.Tetra.LogicChannel,System.Exception,System.String,System.String,System.Collections.Generic.Dictionary`2<SDRSharp.Tetra.GlobalNames,System.Int32>)
		// File path: C:\SDRSharp\Plugins\Tetra\SDRSharp.Tetra.dll
		// 
		// Product version: 0.0.0.0
		// Exception in: System.Void ​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(SDRSharp.Tetra.LogicChannel,System.Exception,System.String,System.String,System.Collections.Generic.Dictionary<SDRSharp.Tetra.GlobalNames,System.Int32>)
		// 
		// Not supported type System.Object.
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetTypeIndex(TypeDefinition type) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 684
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetContainingType(TypeDefinition leftType, TypeDefinition rightType) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 608
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 492
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.get_ExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 414
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddAssignmentCastIfNeeded(Expression expr) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 112
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.FixAssignmentInList(IList`1 expressionList, Expression value) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 75
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddCasts() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 38
		//    at Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.Process(DecompilationContext theContext, BlockStatement body) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\ExpressionDecompilerStep.cs:line 68
		//    at Telerik.JustDecompiler.Decompiler.DecompilationPipeline.RunInternal(MethodBody body, BlockStatement block, ILanguage language) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\DecompilationPipeline.cs:line 100
		//    at Telerik.JustDecompiler.Decompiler.WriterContextServices.BaseWriterContextService.DecompileMethod(ILanguage language, MethodDefinition method, TypeSpecificContext typeContext) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\WriterContextServices\BaseWriterContextService.cs:line 133
		// 
		// mailto: JustDecompilePublicFeedback@telerik.com

	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	// ​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮
	public static void u200b‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(Exception , string , bool , string  = "", Dictionary<GlobalNames, int>  = null)
	{
		// 
		// Current member / type: System.Void ⁫⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮::​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(System.Exception,System.String,System.Boolean,System.String,System.Collections.Generic.Dictionary`2<SDRSharp.Tetra.GlobalNames,System.Int32>)
		// File path: C:\SDRSharp\Plugins\Tetra\SDRSharp.Tetra.dll
		// 
		// Product version: 0.0.0.0
		// Exception in: System.Void ​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(System.Exception,System.String,System.Boolean,System.String,System.Collections.Generic.Dictionary<SDRSharp.Tetra.GlobalNames,System.Int32>)
		// 
		// Not supported type System.Object.
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetTypeIndex(TypeDefinition type) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 684
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetContainingType(TypeDefinition leftType, TypeDefinition rightType) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 608
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 492
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.get_ExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 414
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddAssignmentCastIfNeeded(Expression expr) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 112
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.FixAssignmentInList(IList`1 expressionList, Expression value) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 75
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddCasts() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 38
		//    at Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.Process(DecompilationContext theContext, BlockStatement body) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\ExpressionDecompilerStep.cs:line 68
		//    at Telerik.JustDecompiler.Decompiler.DecompilationPipeline.RunInternal(MethodBody body, BlockStatement block, ILanguage language) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\DecompilationPipeline.cs:line 100
		//    at Telerik.JustDecompiler.Decompiler.WriterContextServices.BaseWriterContextService.DecompileMethod(ILanguage language, MethodDefinition method, TypeSpecificContext typeContext) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\WriterContextServices\BaseWriterContextService.cs:line 133
		// 
		// mailto: JustDecompilePublicFeedback@telerik.com

	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	// ​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮
	public static unsafe void u200b‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(Exception , string , float* )
	{
		// 
		// Current member / type: System.Void ⁫⁯⁬‫⁬⁬‎‭⁪‫‎‭‍‎‪⁬‪⁭‬⁬‬‍⁪‭‌⁬⁯⁯‌⁯⁮‪‍‍‫‮​‎⁭‎‮::​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(System.Exception,System.String,System.Single*)
		// File path: C:\SDRSharp\Plugins\Tetra\SDRSharp.Tetra.dll
		// 
		// Product version: 0.0.0.0
		// Exception in: System.Void ​‪‪‭‎‎​‏‬‭‏⁪⁬‬‭‎⁭⁬⁮⁬‭⁪⁭⁭‬‮⁪‮‎‍‫‭⁪‮‫‌⁯⁭‬⁭‮(System.Exception,System.String,System.Single*)
		// 
		// Not supported type System.Object.
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetTypeIndex(TypeDefinition type) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 684
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetContainingType(TypeDefinition leftType, TypeDefinition rightType) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 608
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.GetExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 492
		//    at Telerik.JustDecompiler.Ast.Expressions.BinaryExpression.get_ExpressionType() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Ast\Expressions\BinaryExpression.cs:line 414
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddAssignmentCastIfNeeded(Expression expr) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 112
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.FixAssignmentInList(IList`1 expressionList, Expression value) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 75
		//    at Telerik.JustDecompiler.Decompiler.TypeInference.TypeInferer.AddCasts() in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\TypeInference\TypeInferer.cs:line 38
		//    at Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.Process(DecompilationContext theContext, BlockStatement body) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\ExpressionDecompilerStep.cs:line 68
		//    at Telerik.JustDecompiler.Decompiler.DecompilationPipeline.RunInternal(MethodBody body, BlockStatement block, ILanguage language) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\DecompilationPipeline.cs:line 100
		//    at Telerik.JustDecompiler.Decompiler.WriterContextServices.BaseWriterContextService.DecompileMethod(ILanguage language, MethodDefinition method, TypeSpecificContext typeContext) in D:\a\CodemerxDecompile\CodemerxDecompile\src\JustDecompileEngine\src\JustDecompiler.Shared\Decompiler\WriterContextServices\BaseWriterContextService.cs:line 133
		// 
		// mailto: JustDecompilePublicFeedback@telerik.com

	}

	// ‭‭‍⁯​‏​‎⁪‏‌⁪‪‭‏⁪‬‏‬⁭⁬⁫⁭‫⁫‮‬⁭‌⁫⁬⁭⁮⁪⁭⁮⁫‎⁮‪‮
	// privatescope
	internal static decimal u202d‭‍⁯​‏​‎⁪‏‌⁪‪‭‏⁪‬‏‬⁭⁬⁫⁭‫⁫‮‬⁭‌⁫⁬⁭⁮⁪⁭⁮⁫‎⁮‪‮(decimal num)
	{
		return Math.Round(num);
	}

	// ‫‫‫‏‮‌⁮‏‫‪‍⁮⁫‌⁯‮⁭‌‍‮⁮‬‌‫⁭‮⁯‪⁪‎‍‭⁭‬‪‎‬‎​‪‮
	// privatescope
	internal static string u202b‫‫‏‮‌⁮‏‫‪‍⁮⁫‌⁯‮⁭‌‍‮⁮‬‌‫⁭‮⁯‪⁪‎‍‭⁭‬‪‎‬‎​‪‮(object obj, object obj)
	{
		return string.Concat(obj, obj);
	}

	// ‮‪​⁪⁮⁫‬‪⁭⁪‫‍⁮​‎⁬⁫​⁮⁪⁭‮‌⁬‮‬⁭‫​⁮‭‭‪‫⁮‭‮‎‬⁮‮
	// privatescope
	internal static string u202e‪​⁪⁮⁫‬‪⁭⁪‫‍⁮​‎⁬⁫​⁮⁪⁭‮‌⁬‮‬⁭‫​⁮‭‭‪‫⁮‭‮‎‬⁮‮()
	{
		return Application.ExecutablePath;
	}

	// ‏‫​⁪‎⁪⁮‌⁯⁪⁯⁮‌‬‏‌‭⁯⁯‍⁪‬‫‌‏‭‫‏​‍​‫⁫‎⁭⁭‫⁭⁭‭‮
	// privatescope
	internal static string u200f‫​⁪‎⁪⁮‌⁯⁪⁯⁮‌‬‏‌‭⁯⁯‍⁪‬‫‌‏‭‫‏​‍​‫⁫‎⁭⁭‫⁭⁭‭‮(string str)
	{
		return Path.GetDirectoryName(str);
	}

	// ‬‎‎‮⁬‭‬‌‫‍⁫‮⁯‬‭‭⁮​⁭⁪⁬⁯⁮‭⁪‏⁪⁭⁪⁬⁭⁬‬‎‏‬‏‪‌‌‮
	// privatescope
	internal static string u202c‎‎‮⁬‭‬‌‫‍⁫‮⁯‬‭‭⁮​⁭⁪⁬⁯⁮‭⁪‏⁪⁭⁪⁬⁭⁬‬‎‏‬‏‪‌‌‮(string[] strArrays)
	{
		return string.Concat(strArrays);
	}

	// ‭⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮
	// privatescope
	internal static string u202d⁫‫‏⁯‫⁮⁬‫⁭​⁫​⁮⁭‮‌⁬‌⁭‏‮‭⁫​⁮‭⁯‫‮‏‫‍‬⁮‍‌‬‬⁫‮()
	{
		return Environment.NewLine;
	}

	// ‮‌⁯‫‫‏⁬‫‎‍‮‬⁮⁬‬⁬⁯⁫‬‬‍‍‏​⁫‪‏‎⁮‭‭⁪‌⁫‮​‏⁫​‮‮
	// privatescope
	internal static string u202e‌⁯‫‫‏⁬‫‎‍‮‬⁮⁬‬⁬⁯⁫‬‬‍‍‏​⁫‪‏‎⁮‭‭⁪‌⁫‮​‏⁫​‮‮(object[] objArray)
	{
		return string.Concat(objArray);
	}

	// ‪⁯‫⁯‭‬‬⁯‫​‏‏‌⁫‫‬⁭⁭​⁫‬⁯⁮⁫‌⁫⁫‪‮‬‏‭‍⁭​⁪‬‌⁭⁮‮
	// privatescope
	internal static void u202a⁯‫⁯‭‬‬⁯‫​‏‏‌⁫‫‬⁭⁭​⁫‬⁯⁮⁫‌⁫⁫‪‮‬‏‭‍⁭​⁪‬‌⁭⁮‮(string str, IEnumerable<string> strs)
	{
		File.AppendAllLines(str, strs);
	}

	// ‭​‍​‮‪‍‏⁮‏‏⁮‏‪⁬⁬⁯‌‮‎‫‌‭‫‏‪​‮‫​‬⁯⁭⁯‌⁬‮‮‏‭‮
	// privatescope
	internal static string u202d​‍​‮‪‍‏⁮‏‏⁮‏‪⁬⁬⁯‌‮‎‫‌‭‫‏‪​‮‫​‬⁯⁭⁯‌⁬‮‮‏‭‮(string str, string str)
	{
		return string.Concat(str, str);
	}

	// ‎⁬⁯‮​‪‎⁪‪‌‍⁬‎‍‍‫⁭‏‏‍⁯​⁭⁮⁯‍‬‪⁮‍‏‎⁫‏‬‫‬⁮‌‍‮
	// privatescope
	internal static StringBuilder u200e⁬⁯‮​‪‎⁪‪‌‍⁬‎‍‍‫⁭‏‏‍⁯​⁭⁮⁯‍‬‪⁮‍‏‎⁫‏‬‫‬⁮‌‍‮()
	{
		return new StringBuilder();
	}

	// ⁯‪⁯‫‮‪⁬‭‍‮‎‍‍⁭⁭⁬‬⁭‫‌‎‌‌‎​​​‬⁮⁪‫‪‫‬‍⁭⁫⁪‌‮‮
	// privatescope
	internal static StringBuilder u206f‪⁯‫‮‪⁬‭‍‮‎‍‍⁭⁭⁬‬⁭‫‌‎‌‌‎​​​‬⁮⁪‫‪‫‬‍⁭⁫⁪‌‮‮(StringBuilder stringBuilder, string str, object obj, object obj, object obj)
	{
		return stringBuilder.AppendFormat(str, obj, obj, obj);
	}

	// ‌‎‏‌⁫⁪⁪​‫⁫⁫⁭⁭‎⁮⁭‮⁪⁮⁯‭‫⁫⁭‏⁪‮‭‏‭‮⁮‎‪⁯⁬⁮‫⁪⁬‮
	// privatescope
	internal static string u200c‎‏‌⁫⁪⁪​‫⁫⁫⁭⁭‎⁮⁭‮⁪⁮⁯‭‫⁫⁭‏⁪‮‭‏‭‮⁮‎‪⁯⁬⁮‫⁪⁬‮(object obj)
	{
		return obj.ToString();
	}

	// ‬⁪‫‫‏‌⁯‬‎‌​⁫⁬​‍‬‮‪‮⁬‎⁬⁪⁬⁮‬‎⁮‎⁫‏‪⁪‬‌⁮​⁫⁭‮
	// privatescope
	internal static string u202c⁪‫‫‏‌⁯‬‎‌​⁫⁬​‍‬‮‪‮⁬‎⁬⁪⁬⁮‬‎⁮‎⁫‏‪⁪‬‌⁮​⁫⁭‮(string str, char[] chrArray)
	{
		return str.TrimEnd(chrArray);
	}

	// ⁬⁬⁬⁮⁯‎⁯⁮⁫‪⁪‭⁭⁬⁬‌‬⁭⁮‍‍​⁭‮⁪⁬‬⁭⁬⁭‏⁭⁫‬‌‏‭‌⁪‎‮
	// privatescope
	internal static string u206c⁬⁬⁮⁯‎⁯⁮⁫‪⁪‭⁭⁬⁬‌‬⁭⁮‍‍​⁭‮⁪⁬‬⁭⁬⁭‏⁭⁫‬‌‏‭‌⁪‎‮(string str, string str, string str)
	{
		return string.Concat(str, str, str);
	}

	// ‍⁫⁫‎⁬‎‪​⁭‌‭⁮‪⁪⁭⁫⁪‫‭‌‌‮⁭‌⁭‏⁬⁭‭⁮‭‪⁫⁫⁯‍‎⁮‪⁮‮
	// privatescope
	internal static DialogResult u200d⁫⁫‎⁬‎‪​⁭‌‭⁮‪⁪⁭⁫⁪‫‭‌‌‮⁭‌⁭‏⁬⁭‭⁮‭‪⁫⁫⁯‍‎⁮‪⁮‮(string str)
	{
		return MessageBox.Show(str);
	}

	// ⁯‏​⁬​‏‏‭​‌‏‏⁬⁭⁬‍⁫‎‌⁪‍⁮‫‍‫⁯‏⁯‬‍‍‫⁪‮⁫⁮‏‪‭‌‮
	// privatescope
	internal static StringBuilder u206f‏​⁬​‏‏‭​‌‏‏⁬⁭⁬‍⁫‎‌⁪‍⁮‫‍‫⁯‏⁯‬‍‍‫⁪‮⁫⁮‏‪‭‌‮(StringBuilder stringBuilder, string str, object obj, object obj)
	{
		return stringBuilder.AppendFormat(str, obj, obj);
	}
}