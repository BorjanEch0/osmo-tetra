/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

__int16 __fastcall sub_10001000(__int16 a1, __int16 a2, char *a3, int a4);
_WORD *__fastcall sub_100010D0(int a1, _WORD *a2, _WORD *a3);
_WORD *__fastcall sub_10001160(int a1, _WORD *a2, _WORD *a3);
int __fastcall sub_100012D0(__int16 a1, int a2);
int __cdecl tetra_cdec(__int16 a1, int a2, _WORD *a3, int a4);
int __cdecl tetra_sdec(int a1, __int16 *a2, __int16 *a3);
char *tetra_decode_init_0();
int __fastcall sub_100017A0(__int16 *a1, int a2, __int16 *a3);
__int16 __fastcall sub_10002090(__int16 a1, __int16 *a2);
__int16 __fastcall sub_10002620(__int16 a1, __int16 a2);
int sub_100026F0();
int __fastcall sub_10002870(__int16 a1, char *a2, char *a3);
int __fastcall sub_10003870(__int16 a1, int a2, int a3);
int __fastcall sub_100039B0(__int16 a1, _WORD *a2);
int __fastcall sub_10003A20(__int16 *a1, _DWORD *a2);
int __fastcall sub_10003BC0(int a1, __int16 *a2, _WORD *a3);
int __thiscall sub_10003D20(void *this);
int __fastcall sub_10003DC0(__int16 *a1, _WORD *a2);
int __fastcall sub_10003F40(char *a1, __int16 *a2, _WORD *a3);
__int16 __fastcall sub_10003FD0(int a1, __int16 *a2, char *a3, int a4, int a5, __int16 a6);
int __fastcall sub_10004180(__int16 *a1, _WORD *a2);
__int16 __fastcall sub_10004230(__int16 a1, __int16 a2, void *a3, __int16 *a4, __int16 *a5, int a6, __int16 *a7, _WORD *a8, __int16 *a9, __int16 *a10);
int __fastcall sub_10004920(__int16 a1, __int16 a2, __int16 a3, int a4, int a5);
__int16 __fastcall sub_10004C30(__int16 *a1, __int16 *a2, int a3);
__int16 __thiscall sub_10004E70(char *this);
__int16 __thiscall sub_10004F10(char *this);
int __fastcall sub_10004FB0(__int16 *a1);
__int16 __fastcall sub_10005010(_WORD *a1, __int16 a2, __int16 a3);
int __fastcall sub_100050F0(int a1, int a2);
int __fastcall sub_10005170(__int16 a1, __int16 a2);
// void __noreturn __report_rangecheckfailure(void); weak
void sub_10005AF9();
void __cdecl sub_10005B19(); // idb
void __cdecl sub_10005B46(); // idb
// int __cdecl _clean_type_info_names_internal(_DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern void *(__cdecl *malloc)(size_t Size);
__int16 word_10006110[] = { 0 }; // weak
__int16 word_10006112[35] =
{
  1455,
  2866,
  4236,
  5568,
  6863,
  8124,
  9352,
  10549,
  11716,
  12855,
  13967,
  15054,
  16117,
  17156,
  18172,
  19167,
  20142,
  21097,
  22033,
  22951,
  23852,
  24735,
  25603,
  26455,
  27291,
  28113,
  28922,
  29716,
  30497,
  31266,
  32023,
  32767,
  0,
  0,
  0
}; // weak
__int16 word_10006158[] = { 16384 }; // weak
__int16 word_1000615A[35] =
{
  16743,
  17109,
  17484,
  17867,
  18258,
  18658,
  19066,
  19484,
  19911,
  20347,
  20792,
  21247,
  21713,
  22188,
  22674,
  23170,
  23678,
  24196,
  24726,
  25268,
  25821,
  26386,
  26964,
  27554,
  28158,
  28774,
  29405,
  30048,
  30706,
  31379,
  32066,
  32767,
  0,
  0,
  0
}; // weak
__int128 xmmword_100061A0 = 0xC568E0C000001F403A98520865907530i64; // weak
__int16 word_100061E0[] = { 1 }; // weak
_UNKNOWN unk_100061F0; // weak
wchar_t aUp6ql[6] = L":Up6Ql"; // weak
_UNKNOWN unk_100062A0; // weak
_UNKNOWN unk_100062C0; // weak
__int16 word_10006320[] = { 1 }; // weak
_UNKNOWN unk_10006330; // weak
_UNKNOWN unk_10006380; // weak
_UNKNOWN unk_100063C0; // weak
wchar_t a08Abcdefjksxyz[48] = L"#$%&'()*+/08=>?@ABCDEFJKSXYZ[\\]^_`aefnstuvwxyz{|"; // weak
_UNKNOWN unk_10006470; // weak
_UNKNOWN unk_100064B0; // weak
_UNKNOWN unk_100064D0; // weak
_UNKNOWN unk_10006510; // weak
_UNKNOWN unk_10006550; // weak
_UNKNOWN unk_10006570; // weak
_UNKNOWN unk_10006590; // weak
__int16 word_100065E0[] = { 1 }; // weak
_UNKNOWN unk_10006600; // weak
_UNKNOWN unk_10006640; // weak
wchar_t asc_10006680[4] = L"\b\t\t\b"; // weak
void (*dword_10006778[2])(void) = { NULL, NULL }; // weak
void (*dword_10006780[2])(void) = { NULL, NULL }; // weak
_UNKNOWN unk_10007018; // weak
__int16 word_10007618[] = { 12 }; // weak
__int16 word_1000761A[] = { 48 }; // weak
_UNKNOWN unk_10007718; // weak
_UNKNOWN unk_10008318; // weak
_UNKNOWN unk_10009644; // weak
int dword_1000964C; // weak
int dword_10009650; // weak
__int16 word_10009680[]; // weak
__int16 word_100096C0[]; // weak
__int16 word_100096E0[32]; // weak
__int16 word_10009720[]; // weak
_UNKNOWN unk_10009722; // weak
__int16 word_10009740; // weak
__int16 word_10009760[32]; // weak
__int16 word_100097A0[480]; // weak
__int16 word_10009B60; // weak
__int16 word_10009B62; // weak
__int16 word_10009B64; // weak
__int16 word_10009B80[]; // weak
__int16 word_10009BC0; // weak


//----- (10001000) --------------------------------------------------------
__int16 __fastcall sub_10001000(__int16 a1, __int16 a2, char *a3, int a4)
{
  char *v5; // edx
  __int16 v6; // cx
  __int16 *v7; // edx
  __int16 v8; // di
  int v9; // ecx
  __int16 *v10; // eax
  __int16 v12[286]; // [esp+Ch] [ebp-240h] BYREF

  if ( a1 )
    sub_100026F0();
  if ( a2 )
  {
    v5 = a3 + 432;
    v6 = a2;
  }
  else
  {
    v5 = a3;
    v6 = 0;
  }
  sub_10002870(v6, v5, (char *)v12);
  v8 = sub_10002090(a2, v12);
  LOWORD(v9) = 51;
  if ( !a2 )
    LOWORD(v9) = 102;
  v10 = v7;
  v9 = (unsigned __int16)v9;
  do
  {
    *v10 = *v10 < 0;
    ++v10;
    --v9;
  }
  while ( v9 );
  if ( a2 )
    sub_10003870(a2, (int)v12, a4 + 274);
  else
    sub_10003870(0, (int)v12, a4);
  return v8;
}
// 1000106A: variable 'v7' is possibly undefined
// 10001000: using guessed type __int16 var_240[286];

//----- (100010D0) --------------------------------------------------------
_WORD *__fastcall sub_100010D0(int a1, _WORD *a2, _WORD *a3)
{
  int v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  _WORD *result; // eax

  v4 = 1;
  v5 = a1;
  while ( v5 <= 0x3FFFFFFF )
  {
    if ( v5 < -1073741824 )
    {
      v5 = 0x80000000;
      goto LABEL_8;
    }
    --v4;
    v5 *= 2;
    if ( (__int16)v4 <= 0 )
      goto LABEL_9;
  }
  v5 = 0x7FFFFFFF;
LABEL_8:
  dword_10009650 = 1;
LABEL_9:
  v6 = v5 >> 16;
  *a2 = v6;
  v7 = -32768 * (__int16)v6;
  v8 = v7 + a1;
  if ( (a1 ^ v7) < 0 )
  {
    result = a3;
  }
  else
  {
    result = a3;
    if ( (a1 ^ v8) < 0 )
    {
      dword_10009650 = 1;
      *a3 = (a1 < 0) - 1;
      return result;
    }
  }
  *result = v8;
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10001160) --------------------------------------------------------
_WORD *__fastcall sub_10001160(int a1, _WORD *a2, _WORD *a3)
{
  _WORD *result; // eax
  int v5; // eax
  int i; // esi
  int v7; // edx
  int v8; // eax
  int v9; // edx
  __int16 v10; // ax
  __int16 v11; // dx
  int v12; // eax
  int v13; // esi
  int v14; // ecx
  int v15; // esi
  __int16 v16; // ax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx

  if ( a1 > 0 )
  {
    v5 = a1;
    for ( i = 0; v5 < 0x40000000; ++i )
      v5 *= 2;
    v7 = sub_100050F0(a1, i);
    v8 = 30 - (__int16)i;
    if ( v8 <= 0x7FFF )
    {
      if ( v8 < -32768 )
        LOWORD(v8) = 0x8000;
    }
    else
    {
      LOWORD(v8) = 0x7FFF;
    }
    *a2 = v8;
    if ( v7 >= 0 )
      v9 = v7 >> 9;
    else
      v9 = ~(~v7 >> 9);
    v10 = HIWORD(v9);
    if ( v9 >= 0 )
      v9 >>= 1;
    else
      LOWORD(v9) = ~(unsigned __int16)(~v9 >> 1);
    v11 = v9 & 0x7FFF;
    v12 = v10 - 32;
    if ( v12 <= 0x7FFF )
    {
      if ( v12 < -32768 )
        LOWORD(v12) = 0x8000;
    }
    else
    {
      LOWORD(v12) = 0x7FFF;
    }
    v13 = word_10006110[(__int16)v12];
    v14 = v13 - word_10006112[(__int16)v12];
    v15 = v13 << 16;
    if ( v14 <= 0x7FFF )
    {
      if ( v14 >= -32768 )
      {
        dword_10009650 = 0;
        v16 = v14;
      }
      else
      {
        dword_10009650 = 1;
        v16 = 0x8000;
      }
    }
    else
    {
      dword_10009650 = 1;
      v16 = 0x7FFF;
    }
    v17 = v11 * v16;
    if ( v17 == 0x40000000 )
    {
      dword_10009650 = 1;
      v18 = 0x7FFFFFFF;
    }
    else
    {
      v18 = 2 * v17;
    }
    v19 = v15 - v18;
    if ( (v15 ^ v18) < 0 && (v15 ^ v19) < 0 )
    {
      dword_10009650 = 1;
      v19 = (v15 < 0) + 0x7FFFFFFF;
    }
    result = a3;
    *a3 = HIWORD(v19);
  }
  else
  {
    *a2 = 0;
    result = a3;
    *a3 = 0;
  }
  return result;
}
// 10001180: conditional instruction was optimized away because ecx.4>=1
// 10006110: using guessed type __int16 word_10006110[];
// 10006112: using guessed type __int16 word_10006112[35];
// 10009650: using guessed type int dword_10009650;

//----- (100012D0) --------------------------------------------------------
int __fastcall sub_100012D0(__int16 a1, int a2)
{
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // dx
  int v6; // ecx
  int v7; // esi
  int v8; // ecx
  __int16 v9; // ax
  int v10; // esi
  int v11; // eax
  int v12; // ebx
  int v13; // ecx
  int result; // eax
  __int16 v15; // si
  int v16; // edx

  a2 = (__int16)a2;
  v3 = 6;
  while ( 1 )
  {
    if ( a2 > 0x3FFFFFFF )
    {
      a2 = 0x7FFFFFFF;
      v4 = 0x7FFF;
      goto LABEL_10;
    }
    if ( a2 < -1073741824 )
      break;
    --v3;
    a2 *= 2;
    if ( (__int16)v3 <= 0 )
      goto LABEL_7;
  }
  a2 = 0x80000000;
LABEL_7:
  v4 = HIWORD(a2);
  if ( a2 < 0 )
  {
    LOWORD(a2) = ~(unsigned __int16)(~a2 >> 1);
    goto LABEL_11;
  }
LABEL_10:
  a2 >>= 1;
LABEL_11:
  v5 = a2 & 0x7FFF;
  v6 = word_10006158[v4];
  v7 = v6 - word_1000615A[v4];
  v8 = v6 << 16;
  if ( v7 <= 0x7FFF )
  {
    v9 = 0x8000;
    if ( v7 >= -32768 )
      v9 = v7;
  }
  else
  {
    v9 = 0x7FFF;
  }
  v10 = v5 * v9;
  v11 = 2 * v10;
  if ( v10 == 0x40000000 )
    v11 = 0x7FFFFFFF;
  v12 = v8 - v11;
  if ( (v8 ^ v11) < 0 && (v8 ^ v12) < 0 )
    v12 = (v8 < 0) + 0x7FFFFFFF;
  v13 = 30 - a1;
  if ( v13 > 0x7FFF )
  {
    dword_10009650 = 1;
    return 0;
  }
  if ( v13 >= -32768 )
  {
    dword_10009650 = 0;
    v15 = 30 - a1;
    if ( (__int16)v13 > 31 )
      return 0;
    if ( (v13 & 0x8000u) == 0 )
    {
      if ( (__int16)v13 < 31 )
      {
        if ( v12 >= 0 )
          v16 = v12 >> v13;
        else
          v16 = ~(~v12 >> v13);
      }
      else
      {
        v16 = (v12 >= 0) - 1;
      }
    }
    else
    {
      v16 = sub_100050F0(v12, -(unsigned __int16)v13);
    }
  }
  else
  {
    v15 = 0x8000;
    dword_10009650 = 1;
    v16 = sub_100050F0(v12, 0x8000);
  }
  if ( v15 <= 0 )
    return v16;
  result = v16 + 1;
  if ( ((1 << (v15 - 1)) & v12) == 0 )
    return v16;
  return result;
}
// 10006158: using guessed type __int16 word_10006158[];
// 1000615A: using guessed type __int16 word_1000615A[35];
// 10009650: using guessed type int dword_10009650;

//----- (10001460) --------------------------------------------------------
int __cdecl tetra_cdec(__int16 a1, int a2, _WORD *a3, int a4)
{
  int i; // ecx
  __int16 v5; // ax
  int v6; // ebx
  int v7; // edi
  char *v8; // ecx
  int v9; // esi
  __int64 v10; // rax
  char *v11; // edi
  int v12; // ebx
  __int16 *v13; // eax
  char *v14; // edx
  int v15; // esi
  __int16 v16; // cx
  __int16 v17; // ax
  int result; // eax
  char v19[432]; // [esp+14h] [ebp-6C4h] BYREF
  char v20; // [esp+1C4h] [ebp-514h] BYREF
  __int16 v21[283]; // [esp+374h] [ebp-364h] BYREF
  char v22[272]; // [esp+5AAh] [ebp-12Eh] BYREF
  __int16 v23; // [esp+6BAh] [ebp-1Eh]

  for ( i = 0; i < 432; ++i )
  {
    v5 = 127;
    if ( *(_BYTE *)(i + a2) )
      v5 = -127;
    v21[i] = v5;
  }
  v6 = a4;
  dword_1000964C = a4;
  if ( a4 )
  {
    v7 = 216;
    v8 = &v20;
    v9 = 101;
    do
    {
      v8 += 2;
      v10 = v9;
      v9 += 101;
      *((_WORD *)v8 - 1) = v21[v10 % 216 + 216];
      --v7;
    }
    while ( v7 );
    qmemcpy(v19, v21, sizeof(v19));
  }
  else
  {
    v11 = v19;
    v12 = 18;
    v13 = v21;
    do
    {
      v14 = v11;
      v15 = 24;
      do
      {
        v16 = *v13;
        v14 += 36;
        ++v13;
        *((_WORD *)v14 - 18) = v16;
        --v15;
      }
      while ( v15 );
      v11 += 2;
      --v12;
    }
    while ( v12 );
    v6 = 0;
  }
  v17 = sub_10001000(a1, v6, v19, (int)&v21[146]);
  if ( !v6 && v17 == 1 )
    LOWORD(v6) = 1;
  *a3 = v6;
  qmemcpy(a3 + 1, &v21[146], 0x110u);
  a3[138] = v17;
  result = 0;
  a3[137] = v21[282];
  qmemcpy(a3 + 139, v22, 0x110u);
  a3[275] = v23;
  return result;
}
// 1000964C: using guessed type int dword_1000964C;

//----- (100015C0) --------------------------------------------------------
int __cdecl tetra_sdec(int a1, __int16 *a2, __int16 *a3)
{
  __int16 v4[138]; // [esp+14h] [ebp-148h] BYREF
  __int16 v5[24]; // [esp+128h] [ebp-34h] BYREF

  qmemcpy(v4, (const void *)a1, sizeof(v4));
  sub_10004180(v4, v5);
  sub_100017A0(v5, (int)a2, a3);
  sub_10004FB0(a2);
  qmemcpy(v4, (const void *)(a1 + 276), sizeof(v4));
  sub_10004180(v4, v5);
  sub_100017A0(v5, (int)(a2 + 240), a3);
  return sub_10004FB0(a2 + 240);
}
// 100015C0: using guessed type __int16 var_34[24];
// 100015C0: using guessed type __int16 var_148[138];

//----- (10001690) --------------------------------------------------------
char *tetra_decode_init_0()
{
  char *v0; // ebx
  _WORD *v1; // esi
  int v2; // edi
  int v3; // eax
  int v4; // edx
  int v5; // eax

  v0 = (char *)malloc(0x3B8u);
  *((_DWORD *)v0 + 236) = 3932160;
  *(_OWORD *)(v0 + 900) = 0i64;
  v1 = v0 + 802;
  *(_OWORD *)(v0 + 916) = 0i64;
  *(_QWORD *)(v0 + 932) = 0i64;
  *((_DWORD *)v0 + 235) = 0;
  *((_DWORD *)v0 + 199) = v0 + 316;
  *((_DWORD *)v0 + 237) = 0;
  memset(v0, 0, 0x13Cu);
  *((_OWORD *)v0 + 55) = 0i64;
  *((_DWORD *)v0 + 224) = 0;
  v2 = 9;
  *(__m128i *)(v0 + 840) = _mm_loadu_si128((const __m128i *)&xmmword_100061A0);
  *((_DWORD *)v0 + 214) = -1703891464;
  *((_WORD *)v0 + 400) = 24576;
  do
  {
    v3 = (__int16)*(v1 - 1);
    if ( 24576 * v3 == 0x40000000 )
    {
      dword_10009650 = 1;
      v4 = 0x7FFFFFFF;
    }
    else
    {
      v4 = 49152 * v3;
    }
    v5 = v4 + 0x8000;
    if ( v4 >= 0 && (v4 ^ v5) < 0 )
    {
      dword_10009650 = 1;
      v5 = (v4 < 0) + 0x7FFFFFFF;
    }
    *v1++ = HIWORD(v5);
    --v2;
  }
  while ( v2 );
  sub_100039B0(27853, (_WORD *)v0 + 410);
  return v0;
}
// 100061A0: using guessed type __int128 xmmword_100061A0;
// 10009650: using guessed type int dword_10009650;

//----- (100017A0) --------------------------------------------------------
int __fastcall sub_100017A0(__int16 *a1, int a2, __int16 *a3)
{
  int v3; // ebx
  __int16 i; // si
  unsigned int v5; // eax
  __int16 *v6; // edi
  _WORD *v7; // ecx
  _WORD *v8; // edx
  __int16 *v9; // ecx
  int v10; // esi
  __int16 v11; // ax
  __int16 *v12; // edx
  int v13; // esi
  __int16 v14; // ax
  int v15; // edx
  __int16 v16; // ax
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // edi
  int v23; // eax
  int v24; // eax
  int v25; // ecx
  __int16 v26; // ax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // esi
  int v31; // eax
  int v32; // edx
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int v41; // edx
  __int16 v42; // ax
  int v43; // ebx
  __m128i v44; // xmm0
  int v45; // ecx
  __int128 *v46; // esi
  __int16 *v47; // edx
  int v48; // edi
  int v49; // eax
  int v50; // ecx
  __int16 v51; // ax
  __int16 *v52; // esi
  int v53; // ecx
  int v54; // ecx
  __int16 *v55; // edi
  int v56; // esi
  int v57; // ebx
  int v58; // edx
  int v59; // eax
  int v60; // ecx
  int v61; // eax
  char *v62; // edi
  int result; // eax
  _WORD *v64; // esi
  _WORD *v65; // edi
  int j; // ecx
  int v67; // [esp+Ch] [ebp-24Ch]
  int v69; // [esp+28h] [ebp-230h]
  __int16 v70; // [esp+2Ch] [ebp-22Ch]
  __int16 v71; // [esp+30h] [ebp-228h] BYREF
  int v72; // [esp+34h] [ebp-224h]
  int v73; // [esp+38h] [ebp-220h]
  __int16 *v74; // [esp+3Ch] [ebp-21Ch]
  __int16 *v75; // [esp+40h] [ebp-218h]
  char *v76; // [esp+44h] [ebp-214h]
  __int16 v77; // [esp+48h] [ebp-210h] BYREF
  int v78; // [esp+4Ch] [ebp-20Ch]
  int v79; // [esp+50h] [ebp-208h]
  _WORD v80[44]; // [esp+54h] [ebp-204h] BYREF
  __int16 v81[128]; // [esp+ACh] [ebp-1ACh] BYREF
  __m128i v82; // [esp+1ACh] [ebp-ACh] BYREF
  int v83; // [esp+1BCh] [ebp-9Ch]
  __int16 v84; // [esp+1C0h] [ebp-98h]
  __int128 v85[6]; // [esp+1C2h] [ebp-96h] BYREF
  __int16 v86; // [esp+222h] [ebp-36h]
  _WORD v87[12]; // [esp+224h] [ebp-34h] BYREF
  __m128i v88; // [esp+23Ch] [ebp-1Ch] BYREF
  int v89; // [esp+24Ch] [ebp-Ch]
  __int16 v90; // [esp+250h] [ebp-8h]

  v3 = (int)a3;
  v74 = a3;
  for ( i = 0; i < 64; ++i )
  {
    v5 = i;
    if ( v5 >= 124 )
      __report_rangecheckfailure();
    v81[v5 + 64] = 0;
  }
  v6 = a1 + 1;
  v70 = *a1;
  v7 = a1 + 1;
  if ( v70 )
  {
    v12 = a3 + 450;
    a3[431] = a3[421];
    v13 = 23;
    a3[432] = a3[422];
    a3[433] = a3[423];
    a3[434] = a3[424];
    a3[435] = a3[425];
    a3[436] = a3[426];
    a3[437] = a3[427];
    a3[438] = a3[428];
    a3[439] = a3[429];
    do
    {
      v14 = *v12++;
      *v7++ = v14;
      --v13;
    }
    while ( v13 );
  }
  else
  {
    sub_10004C30(v6, a3 + 430, (int)(a3 + 420));
    v8 = a3 + 450;
    v9 = v6;
    v10 = 23;
    do
    {
      v11 = *v9++;
      *v8++ = v11;
      --v10;
    }
    while ( v10 );
  }
  v75 = v6 + 3;
  sub_10003BC0((int)(a3 + 420), a3 + 430, v80);
  a3[420] = a3[430];
  LOWORD(v15) = 0;
  a3[421] = a3[431];
  a3[422] = a3[432];
  a3[423] = a3[433];
  a3[424] = a3[434];
  a3[425] = a3[435];
  a3[426] = a3[436];
  a3[427] = a3[437];
  a3[428] = a3[438];
  a3[429] = a3[439];
  v76 = (char *)v80;
  v72 = 0;
  do
  {
    v16 = *v75++;
    if ( !(_WORD)v15 )
    {
      if ( v70 )
      {
        v22 = *(unsigned __int16 *)(v3 + 946);
      }
      else
      {
        if ( v16 < 197 )
        {
          v17 = v16;
          v18 = v16 + 2;
          if ( v18 <= 0x7FFF )
          {
            if ( v18 < -32768 )
              LOWORD(v18) = 0x8000;
          }
          else
          {
            LOWORD(v18) = 0x7FFF;
          }
          v19 = (10923 * (__int16)v18) >> 15;
          if ( (v19 & 0x10000) != 0 )
            v19 |= 0xFFFF0000;
          if ( v19 <= 0x7FFF )
          {
            if ( v19 < -32768 )
              LOWORD(v19) = 0x8000;
          }
          else
          {
            LOWORD(v19) = 0x7FFF;
          }
          v20 = (__int16)v19 + 19;
          if ( v20 <= 0x7FFF )
          {
            if ( v20 < -32768 )
              LOWORD(v20) = 0x8000;
          }
          else
          {
            LOWORD(v20) = 0x7FFF;
          }
          v21 = (__int16)v20;
          LOWORD(v22) = v20;
          v78 = (unsigned __int16)v20;
          v23 = 2 * (__int16)v20;
          if ( v23 <= 0x7FFF )
          {
            if ( v23 < -32768 )
              LOWORD(v23) = 0x8000;
          }
          else
          {
            LOWORD(v23) = 0x7FFF;
          }
          v24 = v21 + (__int16)v23;
          if ( v24 <= 0x7FFF )
          {
            if ( v24 < -32768 )
              LOWORD(v24) = 0x8000;
          }
          else
          {
            LOWORD(v24) = 0x7FFF;
          }
          v25 = 58 - (__int16)v24;
          if ( v25 <= 0x7FFF )
          {
            v26 = 0x8000;
            if ( v25 >= -32768 )
              v26 = v25;
          }
          else
          {
            v26 = 0x7FFF;
          }
          v27 = v17 + v26;
          if ( v27 <= 0x7FFF )
          {
            if ( v27 >= -32768 )
              v79 = (unsigned __int16)v27;
            else
              v79 = 0x8000;
          }
          else
          {
            v79 = 0x7FFF;
          }
LABEL_52:
          v29 = (__int16)v22 - 5;
          if ( v29 <= 0x7FFF )
          {
            if ( v29 >= -32768 )
            {
              LOWORD(v30) = v22 - 5;
              v73 = (unsigned __int16)v29;
              if ( (__int16)v29 >= 20 )
              {
LABEL_58:
                v31 = (__int16)v30 + 9;
                if ( v31 <= 0x7FFF )
                {
                  if ( v31 < -32768 )
                  {
                    dword_10009650 = 1;
LABEL_100:
                    v42 = v79;
                    goto LABEL_101;
                  }
                  dword_10009650 = 0;
                  if ( (__int16)v31 <= 143 )
                    goto LABEL_100;
                }
                dword_10009650 = 0;
                v73 = 134;
                goto LABEL_100;
              }
            }
            v30 = 20;
          }
          else
          {
            v30 = 0x7FFF;
          }
          v73 = v30;
          goto LABEL_58;
        }
        v28 = v16 - 112;
        if ( v28 <= 0x7FFF )
        {
          if ( v28 >= -32768 )
            v22 = (unsigned __int16)v28;
          else
            v22 = 0x8000;
        }
        else
        {
          v22 = 0x7FFF;
        }
      }
      v79 = 0;
      v78 = v22;
      goto LABEL_52;
    }
    if ( v70 )
    {
      LOWORD(v22) = v78;
      goto LABEL_100;
    }
    v32 = v16;
    v33 = v16 + 2;
    if ( v33 <= 0x7FFF )
    {
      if ( v33 < -32768 )
        LOWORD(v33) = 0x8000;
    }
    else
    {
      LOWORD(v33) = 0x7FFF;
    }
    v34 = (10923 * (__int16)v33) >> 15;
    if ( (v34 & 0x10000) != 0 )
      v34 |= 0xFFFF0000;
    if ( v34 <= 0x7FFF )
    {
      if ( v34 < -32768 )
        LOWORD(v34) = 0x8000;
    }
    else
    {
      LOWORD(v34) = 0x7FFF;
    }
    v35 = (__int16)v34 - 1;
    if ( v35 <= 0x7FFF )
    {
      if ( v35 < -32768 )
        LOWORD(v35) = 0x8000;
    }
    else
    {
      LOWORD(v35) = 0x7FFF;
    }
    v36 = (__int16)v35;
    v37 = (__int16)v35 + (__int16)v73;
    if ( v37 <= 0x7FFF )
    {
      if ( v37 < -32768 )
        LOWORD(v37) = 0x8000;
    }
    else
    {
      LOWORD(v37) = 0x7FFF;
    }
    v22 = (unsigned __int16)v37;
    v38 = 2 * v36;
    v78 = v22;
    if ( 2 * v36 <= 0x7FFF )
    {
      if ( v38 < -32768 )
        LOWORD(v38) = 0x8000;
    }
    else
    {
      LOWORD(v38) = 0x7FFF;
    }
    v39 = v36 + (__int16)v38;
    if ( v39 <= 0x7FFF )
    {
      if ( v39 < -32768 )
        LOWORD(v39) = 0x8000;
    }
    else
    {
      LOWORD(v39) = 0x7FFF;
    }
    v40 = (__int16)v39 + 2;
    if ( v40 <= 0x7FFF )
    {
      if ( v40 < -32768 )
        LOWORD(v40) = 0x8000;
    }
    else
    {
      LOWORD(v40) = 0x7FFF;
    }
    v41 = v32 - (__int16)v40;
    if ( v41 <= 0x7FFF )
    {
      if ( v41 >= -32768 )
      {
        v42 = v41;
        dword_10009650 = 0;
        v79 = (unsigned __int16)v41;
      }
      else
      {
        dword_10009650 = 1;
        v42 = 0x8000;
        v79 = 0x8000;
      }
    }
    else
    {
      dword_10009650 = 1;
      v42 = 0x7FFF;
      v79 = 0x7FFF;
    }
LABEL_101:
    v43 = 2 * (__int16)v72;
    v67 = v43;
    sub_10005010((_WORD *)(v43 + *((_DWORD *)v74 + 199)), v22, v42);
    sub_10003F40(v76, a3 + 400, &v88);
    sub_10003F40(v76, a3 + 410, v87);
    v44 = _mm_loadu_si128(&v88);
    v83 = v89;
    v84 = v90;
    v86 = 0;
    v82 = v44;
    memset(v85, 0, sizeof(v85));
    sub_10003FD0((int)v87, v82.m128i_i16, v82.m128i_i8, v45, (int)v85, 0);
    if ( (__int16)v22 < 60 )
    {
      v46 = (__int128 *)&v82;
      v47 = &v82.m128i_i16[(__int16)v22];
      v48 = (unsigned __int16)(60 - v22);
      do
      {
        v49 = (26216 * *(__int16 *)v46) >> 15;
        if ( (v49 & 0x10000) != 0 )
          v49 |= 0xFFFF0000;
        if ( v49 <= 0x7FFF )
        {
          if ( v49 < -32768 )
            LOWORD(v49) = 0x8000;
        }
        else
        {
          LOWORD(v49) = 0x7FFF;
        }
        v50 = *v47 + (__int16)v49;
        if ( v50 <= 0x7FFF )
        {
          if ( v50 >= -32768 )
          {
            dword_10009650 = 0;
            v51 = v50;
          }
          else
          {
            dword_10009650 = 1;
            v51 = 0x8000;
          }
        }
        else
        {
          dword_10009650 = 1;
          v51 = 0x7FFF;
        }
        *v47 = v51;
        v46 = (__int128 *)((char *)v46 + 2);
        ++v47;
        --v48;
      }
      while ( v48 );
    }
    v52 = v75;
    sub_10004920(*v75, v75[1], v75[2], (int)&v82, (int)v81);
    v53 = (unsigned __int16)v52[3];
    v75 = v52 + 4;
    sub_10004230(v53, v70, v76, (__int16 *)(v43 + *((_DWORD *)v74 + 199)), v81, v53, &v77, &v71, a3 + 475, a3 + 474);
    v54 = v77;
    v55 = v81;
    v69 = 60;
    v56 = v43;
    do
    {
      v57 = *((_DWORD *)v74 + 199);
      v58 = v54 * *(__int16 *)(v57 + v56);
      v59 = v71 * *v55;
      v60 = v59 + v58;
      if ( (v58 ^ v59) >= 0 && (v58 ^ v60) < 0 )
      {
        dword_10009650 = 1;
        v60 = (v58 < 0) + 0x7FFFFFFF;
      }
      if ( v60 >= 0 )
        v61 = v60 >> 12;
      else
        v61 = ~(~v60 >> 12);
      if ( (v60 & 0x800) != 0 )
        LOWORD(v61) = v61 + 1;
      v54 = v77;
      ++v55;
      *(_WORD *)(v57 + v56) = v61;
      v56 += 2;
      --v69;
    }
    while ( v69 );
    v3 = (int)v74;
    v62 = v76;
    sub_10003FD0((int)v76, (__int16 *)(v67 + *((_DWORD *)v74 + 199)), (char *)(v67 + a2), v54, (int)(a3 + 440), 1);
    v15 = v72 + 60;
    v76 = v62 + 22;
    v72 = v15;
  }
  while ( (__int16)v15 < 240 );
  result = v78;
  v64 = (_WORD *)(v3 + 480);
  v65 = (_WORD *)v3;
  for ( j = 158; j; --j )
    *v65++ = *v64++;
  *(_WORD *)(v3 + 946) = result;
  return result;
}
// 10001E1A: variable 'v45' is possibly undefined
// 10005362: using guessed type void __noreturn __report_rangecheckfailure(void);
// 10009650: using guessed type int dword_10009650;
// 100017A0: using guessed type _WORD var_204[44];
// 100017A0: using guessed type _WORD var_34[12];

//----- (10002090) --------------------------------------------------------
__int16 __fastcall sub_10002090(__int16 a1, __int16 *a2)
{
  __int16 v2; // di
  __int16 *v3; // esi
  int v4; // ebx
  int v5; // ecx
  int v6; // ecx
  __int16 v7; // di
  __int16 *v8; // esi
  int v9; // ebx
  int v10; // ecx
  int v11; // ecx
  __int16 v12; // di
  __int16 *v13; // esi
  int v14; // ebx
  int v15; // ecx
  int v16; // ecx
  __int16 v17; // di
  __int16 *v18; // esi
  int v19; // ebx
  int v20; // ecx
  int v21; // ecx
  __int16 v22; // di
  __int16 *v23; // esi
  int v24; // ebx
  int v25; // ecx
  int v26; // ecx
  __int16 v27; // di
  __int16 *v28; // esi
  int v29; // ebx
  int v30; // ecx
  int v31; // ecx
  __int16 v32; // di
  __int16 *v33; // esi
  int v34; // ebx
  int v35; // ecx
  int v36; // ecx
  __int16 v37; // di
  __int16 *v38; // esi
  int v39; // ebx
  int v40; // ecx
  int v41; // ecx
  __int16 *v43; // esi
  int v44; // ebx
  int v45; // ecx
  int v46; // ecx
  __int16 v47; // di
  __int16 *v48; // esi
  int v49; // ebx
  int v50; // ecx
  int v51; // ecx
  __int16 v52; // di
  __int16 *v53; // esi
  int v54; // ebx
  int v55; // ecx
  int v56; // ecx
  __int16 v57; // di
  __int16 *v58; // esi
  int v59; // ebx
  int v60; // ecx
  __int16 v61; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v61 = 0;
  if ( a1 )
  {
    v43 = (__int16 *)&unk_100064B0;
    v44 = 16;
    do
    {
      v45 = v2 + a2[*v43 + 106];
      if ( v45 <= 0x7FFF )
      {
        if ( v45 < -32768 )
          LOWORD(v45) = 0x8000;
      }
      else
      {
        LOWORD(v45) = 0x7FFF;
      }
      ++v43;
      v2 = v45;
      --v44;
    }
    while ( v44 );
    v46 = (v45 & 1) - a2[137];
    if ( v46 > 0x7FFF || v46 < -32768 || (_WORD)v46 )
      v61 = 1;
    v47 = 0;
    v48 = (__int16 *)&unk_10006550;
    v49 = 16;
    do
    {
      v50 = v47 + a2[*v48 + 106];
      if ( v50 <= 0x7FFF )
      {
        if ( v50 < -32768 )
          LOWORD(v50) = 0x8000;
      }
      else
      {
        LOWORD(v50) = 0x7FFF;
      }
      ++v48;
      v47 = v50;
      --v49;
    }
    while ( v49 );
    v51 = (v50 & 1) - a2[138];
    if ( v51 > 0x7FFF || v51 < -32768 || (_WORD)v51 )
      v61 = 1;
    v52 = 0;
    v53 = (__int16 *)&unk_10006570;
    v54 = 16;
    do
    {
      v55 = v52 + a2[*v53 + 106];
      if ( v55 <= 0x7FFF )
      {
        if ( v55 < -32768 )
          LOWORD(v55) = 0x8000;
      }
      else
      {
        LOWORD(v55) = 0x7FFF;
      }
      ++v53;
      v52 = v55;
      --v54;
    }
    while ( v54 );
    v56 = (v55 & 1) - a2[139];
    if ( v56 > 0x7FFF || v56 < -32768 || (_WORD)v56 )
      v61 = 1;
    v57 = 0;
    v58 = (__int16 *)&unk_100062A0;
    v59 = 16;
    do
    {
      v60 = v57 + a2[*v58 + 106];
      if ( v60 <= 0x7FFF )
      {
        if ( v60 < -32768 )
          LOWORD(v60) = 0x8000;
      }
      else
      {
        LOWORD(v60) = 0x7FFF;
      }
      ++v58;
      v57 = v60;
      --v59;
    }
    while ( v59 );
    v41 = (v60 & 1) - a2[140];
    if ( v41 > 0x7FFF )
      goto LABEL_119;
  }
  else
  {
    v3 = (__int16 *)&unk_10006510;
    v4 = 29;
    do
    {
      v5 = v2 + a2[*v3 + 213];
      if ( v5 <= 0x7FFF )
      {
        if ( v5 < -32768 )
          LOWORD(v5) = 0x8000;
      }
      else
      {
        LOWORD(v5) = 0x7FFF;
      }
      ++v3;
      v2 = v5;
      --v4;
    }
    while ( v4 );
    v6 = (v5 & 1) - a2[274];
    if ( v6 > 0x7FFF || v6 < -32768 || (_WORD)v6 )
      v61 = 1;
    v7 = 0;
    v8 = (__int16 *)&unk_100064D0;
    v9 = 29;
    do
    {
      v10 = v7 + a2[*v8 + 213];
      if ( v10 <= 0x7FFF )
      {
        if ( v10 < -32768 )
          LOWORD(v10) = 0x8000;
      }
      else
      {
        LOWORD(v10) = 0x7FFF;
      }
      ++v8;
      v7 = v10;
      --v9;
    }
    while ( v9 );
    v11 = (v10 & 1) - a2[275];
    if ( v11 > 0x7FFF || v11 < -32768 || (_WORD)v11 )
      v61 = 1;
    v12 = 0;
    v13 = (__int16 *)&unk_10006380;
    v14 = 29;
    do
    {
      v15 = v12 + a2[*v13 + 213];
      if ( v15 <= 0x7FFF )
      {
        if ( v15 < -32768 )
          LOWORD(v15) = 0x8000;
      }
      else
      {
        LOWORD(v15) = 0x7FFF;
      }
      ++v13;
      v12 = v15;
      --v14;
    }
    while ( v14 );
    v16 = (v15 & 1) - a2[276];
    if ( v16 > 0x7FFF || v16 < -32768 || (_WORD)v16 )
      v61 = 1;
    v17 = 0;
    v18 = (__int16 *)&unk_100061F0;
    v19 = 30;
    do
    {
      v20 = v17 + a2[*v18 + 213];
      if ( v20 <= 0x7FFF )
      {
        if ( v20 < -32768 )
          LOWORD(v20) = 0x8000;
      }
      else
      {
        LOWORD(v20) = 0x7FFF;
      }
      ++v18;
      v17 = v20;
      --v19;
    }
    while ( v19 );
    v21 = (v20 & 1) - a2[277];
    if ( v21 > 0x7FFF || v21 < -32768 || (_WORD)v21 )
      v61 = 1;
    v22 = 0;
    v23 = (__int16 *)&unk_100062C0;
    v24 = 30;
    do
    {
      v25 = v22 + a2[*v23 + 213];
      if ( v25 <= 0x7FFF )
      {
        if ( v25 < -32768 )
          LOWORD(v25) = 0x8000;
      }
      else
      {
        LOWORD(v25) = 0x7FFF;
      }
      ++v23;
      v22 = v25;
      --v24;
    }
    while ( v24 );
    v26 = (v25 & 1) - a2[278];
    if ( v26 > 0x7FFF || v26 < -32768 || (_WORD)v26 )
      v61 = 1;
    v27 = 0;
    v28 = (__int16 *)&unk_10006470;
    v29 = 29;
    do
    {
      v30 = v27 + a2[*v28 + 213];
      if ( v30 <= 0x7FFF )
      {
        if ( v30 < -32768 )
          LOWORD(v30) = 0x8000;
      }
      else
      {
        LOWORD(v30) = 0x7FFF;
      }
      ++v28;
      v27 = v30;
      --v29;
    }
    while ( v29 );
    v31 = (v30 & 1) - a2[279];
    if ( v31 > 0x7FFF || v31 < -32768 || (_WORD)v31 )
      v61 = 1;
    v32 = 0;
    v33 = (__int16 *)&unk_100063C0;
    v34 = 29;
    do
    {
      v35 = v32 + a2[*v33 + 213];
      if ( v35 <= 0x7FFF )
      {
        if ( v35 < -32768 )
          LOWORD(v35) = 0x8000;
      }
      else
      {
        LOWORD(v35) = 0x7FFF;
      }
      ++v33;
      v32 = v35;
      --v34;
    }
    while ( v34 );
    v36 = (v35 & 1) - a2[280];
    if ( v36 > 0x7FFF || v36 < -32768 || (_WORD)v36 )
      v61 = 1;
    v37 = 0;
    v38 = (__int16 *)&unk_10006330;
    v39 = 35;
    do
    {
      v40 = v37 + a2[*v38 + 213];
      if ( v40 <= 0x7FFF )
      {
        if ( v40 < -32768 )
          LOWORD(v40) = 0x8000;
      }
      else
      {
        LOWORD(v40) = 0x7FFF;
      }
      ++v38;
      v37 = v40;
      --v39;
    }
    while ( v39 );
    v41 = (v40 & 1) - a2[281];
    if ( v41 > 0x7FFF )
      goto LABEL_119;
  }
  if ( v41 < -32768 )
  {
LABEL_119:
    dword_10009650 = 1;
    return 1;
  }
  dword_10009650 = 0;
  if ( (_WORD)v41 )
    return 1;
  else
    return v61;
}
// 10009650: using guessed type int dword_10009650;

//----- (10002620) --------------------------------------------------------
__int16 __fastcall sub_10002620(__int16 a1, __int16 a2)
{
  __int16 v2; // bx
  unsigned __int16 v3; // ax
  __int16 v4; // si
  int v5; // ecx
  __int16 v6; // di
  int v7; // eax
  __int16 v8; // ax
  __int16 v9; // ax
  unsigned __int16 v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]

  v2 = 0;
  v3 = a2 & a1;
  v4 = -1;
  v5 = 0;
  v11 = v3;
  v6 = 0;
  v13 = 0;
  LOWORD(v7) = 0;
  v12 = 0;
  do
  {
    if ( v6 >= 0 )
    {
      if ( v6 <= 15 && 1 << v5 == (__int16)(1 << v5) )
      {
        v8 = 1 << v5;
      }
      else
      {
        dword_10009650 = 1;
        v8 = 0x7FFF;
      }
    }
    else if ( v2 >= 0 )
    {
      if ( v2 < 15 )
      {
        v5 = v13;
        v8 = 1 >> v2;
      }
      else
      {
        v8 = 0;
      }
    }
    else
    {
      v8 = sub_10005170(1, v7);
      v5 = v13;
    }
    if ( (v11 & (unsigned __int16)v8) != 0 )
    {
      if ( v4 == (__int16)0x8000 )
        v9 = 0x7FFF;
      else
        v9 = -v4;
      v4 = v9;
    }
    ++v5;
    v7 = v12 + 1;
    v13 = v5;
    ++v6;
    v12 = v7;
    --v2;
  }
  while ( (__int16)v7 <= 4 );
  return v4;
}
// 10009650: using guessed type int dword_10009650;

//----- (100026F0) --------------------------------------------------------
int sub_100026F0()
{
  int v0; // ecx
  int v1; // edi
  __int16 v2; // si
  int v3; // ebx
  int v4; // ecx
  int v5; // edx
  __int16 v6; // ax
  int v7; // eax
  __int16 v8; // dx
  __int16 v9; // ax
  int v10; // ecx
  __int16 v11; // si
  int result; // eax
  bool v13; // zf
  __int16 v14; // [esp+Ch] [ebp-20h]
  int v15; // [esp+10h] [ebp-1Ch]
  __int16 v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  int v18; // [esp+20h] [ebp-Ch]
  int v19; // [esp+24h] [ebp-8h]
  int v20; // [esp+28h] [ebp-4h]

  LOBYTE(v0) = 0;
  word_10009BC0 = 15;
  word_10009740 = 8;
  v1 = 0;
  v18 = 0;
  do
  {
    v19 = 2;
    v2 = v0 & 7;
    v3 = 2 * (v0 & 7);
    v16 = v0 & 8;
    v4 = 2 * (v0 & 8);
    v14 = v2;
    v5 = 0;
    v15 = v4;
    v17 = (__int16)v4;
    v20 = 0;
    do
    {
      if ( v3 == (__int16)v3 )
      {
        v6 = v3;
      }
      else
      {
        v6 = 0x8000;
        if ( v2 > 0 )
          v6 = 0x7FFF;
      }
      v7 = v5 + v6;
      if ( v7 <= 0x7FFF )
      {
        v8 = 0x8000;
        if ( v7 >= -32768 )
          v8 = v7;
      }
      else
      {
        v8 = 0x7FFF;
      }
      word_10009760[v1] = v8;
      if ( v4 == v17 )
      {
        v9 = v4;
      }
      else
      {
        v9 = 0x8000;
        if ( v16 > 0 )
          v9 = 0x7FFF;
      }
      v10 = v8 + v9;
      if ( v10 <= 0x7FFF )
      {
        if ( v10 >= -32768 )
        {
          dword_10009650 = 0;
          v11 = v8 + v9;
        }
        else
        {
          dword_10009650 = 1;
          v11 = 0x8000;
        }
      }
      else
      {
        dword_10009650 = 1;
        v11 = 0x7FFF;
      }
      word_10009680[v1] = sub_10002620(v11, 31);
      word_10009B80[v1] = sub_10002620(v11, 27);
      LOWORD(result) = sub_10002620(v11, 21);
      v4 = v15;
      v5 = v20 + 1;
      v2 = v14;
      word_100096E0[v1++] = result;
      v13 = v19-- == 1;
      ++v20;
    }
    while ( !v13 );
    v0 = v18 + 1;
    v18 = v0;
  }
  while ( (__int16)v0 <= 15 );
  return result;
}
// 10009650: using guessed type int dword_10009650;
// 10009680: using guessed type __int16 word_10009680[];
// 100096E0: using guessed type __int16 word_100096E0[32];
// 10009740: using guessed type __int16 word_10009740;
// 10009760: using guessed type __int16 word_10009760[32];
// 10009B80: using guessed type __int16 word_10009B80[];
// 10009BC0: using guessed type __int16 word_10009BC0;

//----- (10002870) --------------------------------------------------------
int __fastcall sub_10002870(__int16 a1, char *a2, char *a3)
{
  unsigned __int16 v4; // ax
  __int16 v5; // dx
  int v6; // ecx
  char *v7; // edi
  char *v8; // esi
  int v9; // ecx
  __int16 v10; // ax
  char v11; // cf
  int v12; // ecx
  _WORD *v13; // edi
  int i; // ecx
  int v15; // esi
  int v16; // ebx
  int v17; // edi
  __int16 v18; // dx
  __int16 v19; // ax
  int v20; // eax
  __int16 v21; // ax
  __int16 v22; // dx
  __int16 v23; // ax
  int v24; // eax
  __int16 v25; // cx
  int v26; // esi
  int v27; // eax
  int v28; // edi
  int v29; // eax
  __int16 v30; // dx
  __int16 v31; // cx
  int v32; // ecx
  __int16 *v33; // edi
  __int16 *v34; // esi
  int j; // ecx
  int v36; // eax
  __int16 v37; // di
  unsigned int v38; // ebx
  unsigned int v39; // edx
  __int16 v40; // ax
  int v41; // ecx
  __int16 v42; // ax
  int v43; // ecx
  __int16 v44; // ax
  __int16 v45; // dx
  __int16 v46; // si
  __int16 v47; // ax
  int v48; // ecx
  int v49; // ecx
  int v50; // ebx
  __int16 v51; // ax
  __int16 v52; // di
  unsigned int v53; // ebx
  unsigned int v54; // edx
  __int16 v55; // ax
  int v56; // ecx
  __int16 v57; // ax
  int v58; // ecx
  __int16 v59; // ax
  __int16 v60; // dx
  __int16 v61; // si
  __int16 v62; // ax
  int v63; // ecx
  int v64; // ecx
  int v65; // esi
  __int16 *v66; // ecx
  int v67; // edx
  int v68; // eax
  int v69; // eax
  int v70; // edi
  int v71; // eax
  int v72; // eax
  int v73; // esi
  int v74; // ecx
  int v75; // edx
  int v76; // eax
  int v77; // eax
  int v78; // eax
  int v79; // eax
  int v80; // edi
  int v81; // ebx
  int v82; // esi
  __int16 v83; // dx
  __int16 v84; // ax
  int v85; // eax
  __int16 v86; // ax
  int v87; // ebx
  __int16 v88; // dx
  __int16 v89; // ax
  int v90; // eax
  __int16 v91; // si
  int v92; // ebx
  __int16 v93; // dx
  __int16 v94; // ax
  int v95; // eax
  __int16 v96; // dx
  __int16 v97; // ax
  int v98; // eax
  __int16 v99; // ax
  int v100; // edi
  int v101; // eax
  int v102; // edi
  int v103; // eax
  __int16 v104; // dx
  __int16 v105; // cx
  int v106; // ecx
  __int16 *v107; // edi
  __int16 *v108; // esi
  int k; // ecx
  int v110; // eax
  __int16 v111; // di
  unsigned int v112; // ebx
  unsigned int v113; // edx
  __int16 v114; // ax
  int v115; // ecx
  __int16 v116; // ax
  int v117; // ecx
  __int16 v118; // ax
  int v119; // ecx
  __int16 v120; // dx
  __int16 v121; // si
  __int16 v122; // ax
  int v123; // eax
  int v124; // ecx
  int v125; // ebx
  __int16 v126; // ax
  __int16 v127; // di
  unsigned int v128; // ebx
  unsigned int v129; // edx
  __int16 v130; // ax
  int v131; // ecx
  __int16 v132; // ax
  int v133; // ecx
  __int16 v134; // ax
  int v135; // ecx
  __int16 v136; // dx
  __int16 v137; // si
  __int16 v138; // ax
  int v139; // ecx
  int v140; // ecx
  int v141; // esi
  __int16 *v142; // ecx
  int v143; // edx
  int v144; // eax
  int v145; // eax
  int v146; // ecx
  int v147; // esi
  int v148; // edx
  int v149; // eax
  int v150; // eax
  int v151; // eax
  int result; // eax
  int v153; // ebx
  int v154; // ecx
  int v155; // edi
  int v156; // edx
  int v157; // eax
  int v158; // eax
  int v159; // eax
  int v160; // ecx
  __int16 v161; // [esp+Ch] [ebp-6Ch]
  int v162; // [esp+Ch] [ebp-6Ch]
  int v163; // [esp+Ch] [ebp-6Ch]
  int v164; // [esp+10h] [ebp-68h]
  int v165; // [esp+10h] [ebp-68h]
  int v166; // [esp+14h] [ebp-64h]
  __int16 v167; // [esp+18h] [ebp-60h]
  int v168; // [esp+18h] [ebp-60h]
  __int16 v169; // [esp+1Ch] [ebp-5Ch]
  __int16 v170; // [esp+20h] [ebp-58h]
  int v171; // [esp+20h] [ebp-58h]
  int v172; // [esp+24h] [ebp-54h]
  int v173; // [esp+24h] [ebp-54h]
  __int16 v174; // [esp+28h] [ebp-50h]
  int v175; // [esp+2Ch] [ebp-4Ch]
  __int16 v176; // [esp+30h] [ebp-48h]
  signed __int16 v177; // [esp+34h] [ebp-44h]
  __int16 v178; // [esp+34h] [ebp-44h]
  int v179; // [esp+38h] [ebp-40h]
  int v180; // [esp+38h] [ebp-40h]
  __int16 v181; // [esp+3Ch] [ebp-3Ch]
  int v182; // [esp+3Ch] [ebp-3Ch]
  int v183; // [esp+40h] [ebp-38h]
  int v184; // [esp+40h] [ebp-38h]
  __int16 v185; // [esp+48h] [ebp-30h]
  int v186; // [esp+4Ch] [ebp-2Ch]
  __int16 v187; // [esp+4Ch] [ebp-2Ch]
  __int16 v188; // [esp+50h] [ebp-28h]
  __int16 v189; // [esp+50h] [ebp-28h]
  int v191; // [esp+58h] [ebp-20h]
  int v192; // [esp+58h] [ebp-20h]
  __int16 v193; // [esp+5Ch] [ebp-1Ch]
  __int16 v194; // [esp+5Ch] [ebp-1Ch]
  __int16 v195; // [esp+60h] [ebp-18h]
  __int16 v196; // [esp+60h] [ebp-18h]
  __int16 v197; // [esp+64h] [ebp-14h]
  __int16 v198; // [esp+68h] [ebp-10h]
  int v199; // [esp+6Ch] [ebp-Ch]
  __int16 v200; // [esp+70h] [ebp-8h]

  if ( a1 )
  {
    v4 = 51;
    v167 = 56;
    v170 = 30;
    v5 = 84;
    v176 = 81;
    v169 = 4;
  }
  else
  {
    v4 = 102;
    v167 = 112;
    v170 = 60;
    v176 = 162;
    v169 = 8;
    v5 = 168;
  }
  v6 = v4 >> 1;
  qmemcpy(a3, a2, 4 * v6);
  v8 = &a2[4 * v6];
  v7 = &a3[4 * v6];
  v9 = v4 & 1;
  v177 = v4;
  v174 = v5;
  while ( v9 )
  {
    *(_WORD *)v7 = *(_WORD *)v8;
    v8 += 2;
    v7 += 2;
    --v9;
  }
  v191 = 0;
  v186 = 0;
  word_10009720[0] = 0;
  v10 = word_10009BC0;
  v199 = -1;
  v185 = -1;
  if ( word_10009BC0 >= 1 )
  {
    v11 = word_10009BC0 & 1;
    v12 = (unsigned __int16)word_10009BC0 >> 1;
    memset32(&unk_10009722, -1048526464, v12);
    v13 = (_WORD *)((char *)&unk_10009722 + 4 * v12);
    for ( i = v11; i; --i )
      *v13++ = -16000;
    v10 = word_10009BC0;
  }
  v15 = 0;
  v16 = 0;
  word_10009B64 = 0;
  v175 = (v10 + 1) / 2;
  v17 = v177;
  v200 = v161;
  v198 = v161;
  v197 = v161;
  do
  {
    v18 = *(_WORD *)&a2[2 * v17 + 2 * (__int16)v16];
    if ( 2 * v18 == (__int16)(2 * v18) )
    {
      v19 = 2 * v18;
    }
    else
    {
      v19 = 0x8000;
      if ( v18 > 0 )
        v19 = 0x7FFF;
    }
    v20 = v19 - 1;
    if ( v20 <= 0x7FFF )
    {
      if ( v20 < -32768 || (_WORD)v20 == 0x8000 )
        v21 = 0x7FFF;
      else
        v21 = -(__int16)v20;
    }
    else
    {
      v21 = -32767;
    }
    v188 = v21;
    ++v16;
    word_10009B60 = v21;
    v179 = v16;
    if ( word_100065E0[(__int16)v15] )
    {
      v22 = *(_WORD *)&a2[2 * v17 + 2 * (__int16)v16];
      if ( 2 * v22 == (__int16)(2 * v22) )
      {
        v23 = 2 * v22;
      }
      else
      {
        v23 = 0x8000;
        if ( v22 > 0 )
          v23 = 0x7FFF;
      }
      v24 = v23 - 1;
      if ( v24 <= 0x7FFF )
      {
        if ( v24 < -32768 || (_WORD)v24 == 0x8000 )
        {
          ++v16;
          v25 = 0x7FFF;
          v179 = v16;
        }
        else
        {
          ++v16;
          v25 = -(__int16)v24;
          v179 = v16;
        }
      }
      else
      {
        ++v16;
        v25 = -32767;
        v179 = v16;
      }
    }
    else
    {
      v25 = 0;
    }
    v26 = v15 + 1;
    word_10009B62 = v25;
    v27 = (__int16)v26 - 8;
    v193 = v25;
    v172 = v26;
    if ( v27 <= 0x7FFF && v27 >= -32768 )
    {
      if ( (_WORD)v26 == 8 )
        v26 = 0;
      v172 = v26;
    }
    ++v185;
    v28 = v199 + 1;
    v29 = (__int16)++v199 - 30;
    if ( v29 <= 0x7FFF && v29 >= -32768 )
    {
      if ( !(_WORD)v29 )
        v28 = 0;
      v199 = v28;
    }
    v30 = word_10009BC0;
    v31 = 0x8000;
    v195 = 0x8000;
    if ( word_10009BC0 >= 0 )
    {
      v32 = (unsigned __int16)(word_10009BC0 + 1) >> 1;
      qmemcpy(word_100096C0, word_10009720, 4 * v32);
      v34 = &word_10009720[2 * v32];
      v33 = &word_100096C0[2 * v32];
      for ( j = ((_BYTE)v30 + 1) & 1; j; --j )
        *v33++ = *v34++;
      v31 = 0x8000;
      LOWORD(v28) = v199;
    }
    LOWORD(v36) = v175;
    v183 = (unsigned __int16)v175;
    if ( (__int16)v175 <= v30 )
    {
      do
      {
        v37 = 0;
        v164 = (__int16)v36;
        v38 = 2 * (__int16)v36;
        do
        {
          v39 = v38 + v37;
          v40 = v188;
          if ( word_10009680[v39] <= 0 )
          {
            if ( v188 == (__int16)0x8000 )
              v40 = 0x7FFF;
            else
              v40 = -v188;
          }
          v41 = word_100096C0[word_10009760[v39]] + v40;
          if ( v41 <= 0x7FFF )
          {
            if ( v41 < -32768 )
              LOWORD(v41) = 0x8000;
          }
          else
          {
            LOWORD(v41) = 0x7FFF;
          }
          v42 = v193;
          if ( word_10009B80[v39] <= 0 )
          {
            if ( v193 == (__int16)0x8000 )
              v42 = 0x7FFF;
            else
              v42 = -v193;
          }
          v43 = v42 + (__int16)v41;
          if ( v43 <= 0x7FFF )
          {
            v44 = 0x8000;
            if ( v43 >= -32768 )
              v44 = v43;
          }
          else
          {
            v44 = 0x7FFF;
          }
          v45 = v44;
          if ( v37 )
          {
            v46 = v198;
            v48 = v44 - v198;
            if ( v48 <= 0x7FFF && (v48 < -32768 || (__int16)v48 <= 0) )
            {
              v47 = v200;
            }
            else
            {
              v46 = v44;
              v47 = v37;
              v198 = v45;
              v200 = v37;
            }
          }
          else
          {
            v46 = v44;
            v47 = 0;
            v198 = v45;
            v200 = 0;
          }
          ++v37;
        }
        while ( v37 <= 1 );
        word_10009720[v38 / 2] = v46;
        word_100097A0[30 * v164 + (__int16)v199] = word_10009760[v38 + v47];
        v49 = v46 - v195;
        if ( v49 > 0x7FFF || v49 >= -32768 && (__int16)v49 > 0 )
        {
          v197 = v183;
          v195 = v46;
        }
        v50 = v164 - (__int16)v175;
        if ( v50 <= 0x7FFF )
        {
          v51 = 0x8000;
          if ( v50 >= -32768 )
            v51 = v164 - v175;
        }
        else
        {
          v51 = 0x7FFF;
        }
        v181 = v51;
        v52 = 0;
        v165 = v51;
        v53 = 2 * v51;
        do
        {
          v54 = v53 + v52;
          v55 = v188;
          if ( word_10009680[v54] <= 0 )
          {
            if ( v188 == (__int16)0x8000 )
              v55 = 0x7FFF;
            else
              v55 = -v188;
          }
          v56 = word_100096C0[word_10009760[v54]] + v55;
          if ( v56 <= 0x7FFF )
          {
            if ( v56 < -32768 )
              LOWORD(v56) = 0x8000;
          }
          else
          {
            LOWORD(v56) = 0x7FFF;
          }
          v57 = v193;
          if ( word_10009B80[v54] <= 0 )
          {
            if ( v193 == (__int16)0x8000 )
              v57 = 0x7FFF;
            else
              v57 = -v193;
          }
          v58 = v57 + (__int16)v56;
          if ( v58 <= 0x7FFF )
          {
            v59 = 0x8000;
            if ( v58 >= -32768 )
              v59 = v58;
          }
          else
          {
            v59 = 0x7FFF;
          }
          v60 = v59;
          if ( v52 )
          {
            v61 = v198;
            v63 = v59 - v198;
            if ( v63 <= 0x7FFF && (v63 < -32768 || (__int16)v63 <= 0) )
            {
              v62 = v200;
            }
            else
            {
              v61 = v59;
              v62 = v52;
              v198 = v60;
              v200 = v52;
            }
          }
          else
          {
            v61 = v59;
            v62 = 0;
            v198 = v60;
            v200 = 0;
          }
          ++v52;
        }
        while ( v52 <= 1 );
        LOWORD(v28) = v199;
        word_10009720[v53 / 2] = v61;
        word_100097A0[30 * v165 + (__int16)v199] = word_10009760[v53 + v62];
        v64 = v61 - v195;
        if ( v64 <= 0x7FFF && (v64 < -32768 || (__int16)v64 <= 0) )
        {
          v31 = v195;
        }
        else
        {
          v31 = v61;
          v197 = v181;
          v195 = v61;
        }
        v30 = word_10009BC0;
        v36 = v183 + 1;
        v183 = v36;
      }
      while ( (__int16)v36 <= word_10009BC0 );
      v16 = v179;
    }
    if ( v30 >= 0 )
    {
      v65 = v31;
      v66 = word_10009720;
      v67 = (unsigned __int16)(v30 + 1);
      do
      {
        v68 = *v66 - v65;
        if ( v68 <= 0x7FFF )
        {
          if ( v68 < -32768 )
            LOWORD(v68) = 0x8000;
        }
        else
        {
          LOWORD(v68) = 0x7FFF;
        }
        *v66++ = v68;
        --v67;
      }
      while ( v67 );
    }
    v69 = (__int16)v28;
    v70 = v186;
    v71 = v69 - 29;
    if ( v71 <= 0x7FFF && v71 >= -32768 )
    {
      if ( !(_WORD)v71 )
        v70 = 1;
      v186 = v70;
    }
    v72 = (__int16)v70 - 1;
    if ( v72 > 0x7FFF || v72 < -32768 )
    {
      dword_10009650 = 1;
LABEL_147:
      v17 = v177;
      goto LABEL_148;
    }
    dword_10009650 = 0;
    if ( (_WORD)v70 != 1 )
      goto LABEL_147;
    v73 = 29;
    LOWORD(v74) = v197;
    v75 = (unsigned __int16)v199;
    do
    {
      v76 = (__int16)v75--;
      v77 = v76 + 30 * (__int16)v74;
      if ( (v75 & 0x8000u) != 0 )
        v75 = 29;
      LOWORD(v74) = word_100097A0[v77];
      --v73;
    }
    while ( v73 );
    v16 = v179;
    v78 = 13;
    v197 = v74;
    v74 = (__int16)v74;
    while ( v74 <= 0x3FFFFFFF )
    {
      if ( v74 < -1073741824 )
      {
        HIWORD(v74) = 0x8000;
        goto LABEL_144;
      }
      --v78;
      v74 *= 2;
      if ( (__int16)v78 <= 0 )
        goto LABEL_145;
    }
    HIWORD(v74) = 0x7FFF;
LABEL_144:
    dword_10009650 = 1;
LABEL_145:
    v17 = v177;
    v79 = v177 + (__int16)v191++;
    *(_WORD *)&a3[2 * v79] = HIWORD(v74);
LABEL_148:
    v15 = v172;
  }
  while ( (__int16)v16 < v174 );
  v80 = 0;
  v81 = 0;
  v173 = (word_10009BC0 + 1) / 2;
  v171 = (__int16)(v167 + 3 + v169 + v170);
  v82 = v177;
  v182 = v177;
  while ( 1 )
  {
    v83 = *(_WORD *)&a2[2 * v82 + 2 * v174 + 2 * (__int16)v81];
    if ( 2 * v83 == (__int16)(2 * v83) )
    {
      v84 = 2 * v83;
    }
    else
    {
      v84 = 0x8000;
      if ( v83 > 0 )
        v84 = 0x7FFF;
    }
    v85 = v84 - 1;
    if ( v85 <= 0x7FFF )
      v86 = v85 < -32768 || (_WORD)v85 == 0x8000 ? 0x7FFF : -(__int16)v85;
    else
      v86 = -32767;
    v87 = v81 + 1;
    v189 = v86;
    word_10009B60 = v86;
    v88 = *(_WORD *)&a2[2 * v82 + 2 * v174 + 2 * (__int16)v87];
    if ( 2 * v88 == (__int16)(2 * v88) )
    {
      v89 = 2 * v88;
    }
    else
    {
      v89 = 0x8000;
      if ( v88 > 0 )
        v89 = 0x7FFF;
    }
    v90 = v89 - 1;
    if ( v90 <= 0x7FFF )
      v91 = v90 < -32768 || (_WORD)v90 == 0x8000 ? 0x7FFF : -(__int16)v90;
    else
      v91 = -32767;
    v92 = v87 + 1;
    v187 = v91;
    word_10009B62 = v91;
    v184 = v92;
    if ( a1 )
    {
      if ( word_100061E0[(__int16)v80] )
      {
        v96 = *(_WORD *)&a2[2 * v182 + 2 * v174 + 2 * (__int16)v92];
        if ( 2 * v96 == (__int16)(2 * v96) )
        {
          v97 = 2 * v96;
        }
        else
        {
          v97 = 0x8000;
          if ( v96 > 0 )
            v97 = 0x7FFF;
        }
        v98 = v97 - 1;
        if ( v98 <= 0x7FFF )
          v99 = v98 < -32768 || (_WORD)v98 == 0x8000 ? 0x7FFF : -(__int16)v98;
        else
          v99 = -32767;
        v196 = v99;
        word_10009B64 = v99;
        v184 = v92 + 1;
      }
      else
      {
        v196 = 0;
        word_10009B64 = 0;
      }
    }
    else if ( word_10006320[(__int16)v80] )
    {
      v93 = *(_WORD *)&a2[2 * v182 + 2 * v174 + 2 * (__int16)v92];
      if ( 2 * v93 == (__int16)(2 * v93) )
      {
        v94 = 2 * v93;
      }
      else
      {
        v94 = 0x8000;
        if ( v93 > 0 )
          v94 = 0x7FFF;
      }
      v95 = v94 - 1;
      if ( v95 <= 0x7FFF )
      {
        if ( v95 < -32768 || (_WORD)v95 == 0x8000 )
        {
          v196 = 0x7FFF;
          word_10009B64 = 0x7FFF;
          v184 = v92 + 1;
        }
        else
        {
          v196 = -(__int16)v95;
          word_10009B64 = -(__int16)v95;
          v184 = v92 + 1;
        }
      }
      else
      {
        v196 = -32767;
        word_10009B64 = -32767;
        v184 = v92 + 1;
      }
    }
    else
    {
      v196 = 0;
      word_10009B64 = 0;
    }
    v100 = v80 + 1;
    v101 = (__int16)v100 - 8;
    v168 = v100;
    if ( v101 <= 0x7FFF && v101 >= -32768 )
    {
      if ( (_WORD)v100 == 8 )
        v100 = 0;
      v168 = v100;
    }
    ++v185;
    v102 = v199 + 1;
    v103 = (__int16)++v199 - 30;
    if ( v103 <= 0x7FFF && v103 >= -32768 )
    {
      if ( !(_WORD)v103 )
        v102 = 0;
      v199 = v102;
    }
    v104 = word_10009BC0;
    v105 = 0x8000;
    v194 = 0x8000;
    if ( word_10009BC0 >= 0 )
    {
      v106 = (unsigned __int16)(word_10009BC0 + 1) >> 1;
      qmemcpy(word_100096C0, word_10009720, 4 * v106);
      v108 = &word_10009720[2 * v106];
      v107 = &word_100096C0[2 * v106];
      for ( k = ((_BYTE)v104 + 1) & 1; k; --k )
        *v107++ = *v108++;
      v105 = 0x8000;
      LOWORD(v102) = v199;
    }
    LOWORD(v110) = v173;
    v180 = (unsigned __int16)v173;
    if ( (__int16)v173 <= v104 )
    {
      do
      {
        v111 = 0;
        v166 = (__int16)v110;
        v112 = 2 * (__int16)v110;
        do
        {
          v113 = v112 + v111;
          v114 = v189;
          if ( word_10009680[v113] <= 0 )
          {
            if ( v189 == (__int16)0x8000 )
              v114 = 0x7FFF;
            else
              v114 = -v189;
          }
          v115 = word_100096C0[word_10009760[v113]] + v114;
          if ( v115 <= 0x7FFF )
          {
            if ( v115 < -32768 )
              LOWORD(v115) = 0x8000;
          }
          else
          {
            LOWORD(v115) = 0x7FFF;
          }
          v116 = v187;
          if ( word_10009B80[v113] <= 0 )
          {
            if ( v187 == (__int16)0x8000 )
              v116 = 0x7FFF;
            else
              v116 = -v187;
          }
          v117 = v116 + (__int16)v115;
          if ( v117 <= 0x7FFF )
          {
            if ( v117 < -32768 )
              LOWORD(v117) = 0x8000;
          }
          else
          {
            LOWORD(v117) = 0x7FFF;
          }
          v118 = v196;
          if ( word_100096E0[v113] <= 0 )
          {
            if ( v196 == (__int16)0x8000 )
              v118 = 0x7FFF;
            else
              v118 = -v196;
          }
          v119 = v118 + (__int16)v117;
          if ( v119 <= 0x7FFF )
          {
            v120 = 0x8000;
            if ( v119 >= -32768 )
              v120 = v119;
          }
          else
          {
            v120 = 0x7FFF;
          }
          if ( v111 )
          {
            v121 = v198;
            v123 = v120 - v198;
            if ( v123 <= 0x7FFF && (v123 < -32768 || (__int16)v123 <= 0) )
            {
              v122 = v200;
            }
            else
            {
              v121 = v120;
              v122 = v111;
              v198 = v120;
              v200 = v111;
            }
          }
          else
          {
            v121 = v120;
            v122 = 0;
            v198 = v120;
            v200 = 0;
          }
          ++v111;
        }
        while ( v111 <= 1 );
        word_10009720[v112 / 2] = v121;
        word_100097A0[30 * v166 + (__int16)v199] = word_10009760[v112 + v122];
        v124 = v121 - v194;
        if ( v124 > 0x7FFF || v124 >= -32768 && (__int16)v124 > 0 )
        {
          v197 = v180;
          v194 = v121;
        }
        v125 = v166 - (__int16)v173;
        if ( v125 <= 0x7FFF )
        {
          v126 = 0x8000;
          if ( v125 >= -32768 )
            v126 = v166 - v173;
        }
        else
        {
          v126 = 0x7FFF;
        }
        v178 = v126;
        v127 = 0;
        v162 = v126;
        v128 = 2 * v126;
        do
        {
          v129 = v128 + v127;
          v130 = v189;
          if ( word_10009680[v129] <= 0 )
          {
            if ( v189 == (__int16)0x8000 )
              v130 = 0x7FFF;
            else
              v130 = -v189;
          }
          v131 = word_100096C0[word_10009760[v129]] + v130;
          if ( v131 <= 0x7FFF )
          {
            if ( v131 < -32768 )
              LOWORD(v131) = 0x8000;
          }
          else
          {
            LOWORD(v131) = 0x7FFF;
          }
          if ( word_10009B80[v129] <= 0 )
          {
            if ( v187 == (__int16)0x8000 )
              v132 = 0x7FFF;
            else
              v132 = -v187;
          }
          else
          {
            v132 = v187;
          }
          v133 = v132 + (__int16)v131;
          if ( v133 <= 0x7FFF )
          {
            if ( v133 < -32768 )
              LOWORD(v133) = 0x8000;
          }
          else
          {
            LOWORD(v133) = 0x7FFF;
          }
          v134 = v196;
          if ( word_100096E0[v129] <= 0 )
          {
            if ( v196 == (__int16)0x8000 )
              v134 = 0x7FFF;
            else
              v134 = -v196;
          }
          v135 = v134 + (__int16)v133;
          if ( v135 <= 0x7FFF )
          {
            v136 = 0x8000;
            if ( v135 >= -32768 )
              v136 = v135;
          }
          else
          {
            v136 = 0x7FFF;
          }
          if ( v127 )
          {
            v137 = v198;
            v139 = v136 - v198;
            if ( v139 <= 0x7FFF && (v139 < -32768 || (__int16)v139 <= 0) )
            {
              v138 = v200;
            }
            else
            {
              v137 = v136;
              v138 = v127;
              v198 = v136;
              v200 = v127;
            }
          }
          else
          {
            v137 = v136;
            v138 = 0;
            v198 = v136;
            v200 = 0;
          }
          ++v127;
        }
        while ( v127 <= 1 );
        LOWORD(v102) = v199;
        word_10009720[v128 / 2] = v137;
        word_100097A0[30 * v162 + (__int16)v199] = word_10009760[v128 + v138];
        v140 = v137 - v194;
        if ( v140 <= 0x7FFF && (v140 < -32768 || (__int16)v140 <= 0) )
        {
          v105 = v194;
        }
        else
        {
          v105 = v137;
          v197 = v178;
          v194 = v137;
        }
        v104 = word_10009BC0;
        v110 = v180 + 1;
        v180 = v110;
      }
      while ( (__int16)v110 <= word_10009BC0 );
    }
    if ( v104 >= 0 )
    {
      v141 = v105;
      v142 = word_10009720;
      v143 = (unsigned __int16)(v104 + 1);
      do
      {
        v144 = *v142 - v141;
        if ( v144 <= 0x7FFF )
        {
          if ( v144 < -32768 )
            LOWORD(v144) = 0x8000;
        }
        else
        {
          LOWORD(v144) = 0x7FFF;
        }
        *v142++ = v144;
        --v143;
      }
      while ( v143 );
    }
    v145 = v185 - v171;
    if ( v145 <= 0x7FFF )
      break;
    dword_10009650 = 1;
LABEL_309:
    LOWORD(v146) = v197;
    v147 = 29;
    v148 = (unsigned __int16)v102;
    do
    {
      v149 = (__int16)v148--;
      v150 = v149 + 30 * (__int16)v146;
      if ( (v148 & 0x8000u) != 0 )
        v148 = 29;
      LOWORD(v146) = word_100097A0[v150];
      --v147;
    }
    while ( v147 );
    v81 = v184;
    v151 = 13;
    v197 = v146;
    v146 = (__int16)v146;
    while ( v146 <= 0x3FFFFFFF )
    {
      if ( v146 < -1073741824 )
      {
        HIWORD(v146) = 0x8000;
        goto LABEL_320;
      }
      --v151;
      v146 *= 2;
      if ( (__int16)v151 <= 0 )
        goto LABEL_321;
    }
    HIWORD(v146) = 0x7FFF;
LABEL_320:
    dword_10009650 = 1;
LABEL_321:
    v82 = v182;
    result = v182 + (__int16)v191++;
    *(_WORD *)&a3[2 * result] = HIWORD(v146);
    v80 = v168;
    if ( (__int16)v184 >= v176 )
      return result;
  }
  if ( v145 < -32768 )
  {
    dword_10009650 = 1;
    goto LABEL_309;
  }
  dword_10009650 = 0;
  if ( (_WORD)v145 )
    goto LABEL_309;
  v153 = 30;
  LOWORD(v154) = 0;
  v155 = (unsigned __int16)v185;
  v192 = v191 + 30;
  v156 = (unsigned __int16)v199;
  do
  {
    v157 = 13;
    v163 = (__int16)v154;
    v154 = (__int16)v154;
    while ( v154 <= 0x3FFFFFFF )
    {
      if ( v154 < -1073741824 )
      {
        HIWORD(v154) = 0x8000;
        goto LABEL_331;
      }
      --v157;
      v154 *= 2;
      if ( (__int16)v157 <= 0 )
        goto LABEL_331;
    }
    HIWORD(v154) = 0x7FFF;
LABEL_331:
    v158 = (__int16)v155--;
    *(_WORD *)&a3[2 * v182 + 2 * v158] = HIWORD(v154);
    v159 = (__int16)v156--;
    LOWORD(v154) = word_100097A0[30 * v163 + v159];
    if ( (v156 & 0x8000u) != 0 )
      v156 = 29;
    --v153;
  }
  while ( v153 );
  result = v192;
  v160 = (__int16)v192 - 4;
  if ( v160 <= 0x7FFF )
  {
    result = v160 < -32768;
    dword_10009650 = result;
  }
  else
  {
    dword_10009650 = 1;
  }
  return result;
}
// 1000293D: conditional instruction was optimized away because dx.2 is in (==54|==A8)
// 10002FB5: conditional instruction was optimized away because %var_48.2 is in (==51|==A2)
// 1000295D: variable 'v161' is possibly undefined
// 100061E0: using guessed type __int16 word_100061E0[];
// 10006320: using guessed type __int16 word_10006320[];
// 100065E0: using guessed type __int16 word_100065E0[];
// 10009650: using guessed type int dword_10009650;
// 10009680: using guessed type __int16 word_10009680[];
// 100096C0: using guessed type __int16 word_100096C0[];
// 100096E0: using guessed type __int16 word_100096E0[32];
// 10009720: using guessed type __int16 word_10009720[];
// 10009760: using guessed type __int16 word_10009760[32];
// 100097A0: using guessed type __int16 word_100097A0[480];
// 10009B60: using guessed type __int16 word_10009B60;
// 10009B62: using guessed type __int16 word_10009B62;
// 10009B64: using guessed type __int16 word_10009B64;
// 10009B80: using guessed type __int16 word_10009B80[];
// 10009BC0: using guessed type __int16 word_10009BC0;

//----- (10003870) --------------------------------------------------------
int __fastcall sub_10003870(__int16 a1, int a2, int a3)
{
  const wchar_t *v4; // edx
  int v5; // edi
  int v6; // ebx
  int v7; // ecx
  const wchar_t *v8; // edi
  int v9; // edx
  int v10; // ebx
  int v11; // ecx
  __int16 *v12; // edi
  int v13; // edx
  int v14; // ebx
  int v15; // ecx
  int v17; // esi
  int v18; // ecx
  const wchar_t *v19; // edx
  int v20; // esi
  int v21; // ebx
  int v22; // ecx
  __int16 *v23; // edx
  int v24; // esi
  int v25; // ebx
  int v26; // ecx

  v4 = a08Abcdefjksxyz;
  if ( a1 )
  {
    v17 = 51;
    do
    {
      v18 = *(__int16 *)v4++;
      *(_WORD *)(a3 + 2 * v18 - 2) = *(const wchar_t *)((char *)v4 + a2 - (_DWORD)a08Abcdefjksxyz - 2);
      --v17;
    }
    while ( v17 );
    v19 = aUp6ql;
    v20 = a2 + 102;
    v21 = 56;
    do
    {
      v22 = *(__int16 *)v19;
      v20 += 2;
      ++v19;
      *(_WORD *)(a3 + 2 * v22 - 2) = *(_WORD *)(v20 - 2);
      --v21;
    }
    while ( v21 );
    v23 = (__int16 *)&unk_10006590;
    v24 = a2 + 214;
    v25 = 30;
    do
    {
      v26 = *v23;
      v24 += 2;
      ++v23;
      *(_WORD *)(a3 + 2 * v26 - 2) = *(_WORD *)(v24 - 2);
      --v25;
    }
    while ( v25 );
    return 0;
  }
  else
  {
    v5 = a2;
    v6 = 51;
    do
    {
      v7 = *(__int16 *)v4;
      v5 += 4;
      ++v4;
      *(_WORD *)(a3 + 2 * v7 - 2) = *(_WORD *)(v5 - 4);
      *(_WORD *)(a3 + 2 * v7 + 272) = *(_WORD *)(v5 - 2);
      --v6;
    }
    while ( v6 );
    v8 = aUp6ql;
    v9 = a2 + 206;
    v10 = 56;
    do
    {
      v11 = *(__int16 *)v8;
      v9 += 4;
      ++v8;
      *(_WORD *)(a3 + 2 * v11 - 2) = *(_WORD *)(v9 - 6);
      *(_WORD *)(a3 + 2 * v11 + 272) = *(_WORD *)(v9 - 4);
      --v10;
    }
    while ( v10 );
    v12 = (__int16 *)&unk_10006590;
    v13 = a2 + 430;
    v14 = 30;
    do
    {
      v15 = *v12;
      v13 += 4;
      ++v12;
      *(_WORD *)(a3 + 2 * v15 - 2) = *(_WORD *)(v13 - 6);
      *(_WORD *)(a3 + 2 * v15 + 272) = *(_WORD *)(v13 - 4);
      --v14;
    }
    while ( v14 );
    return 0;
  }
}
// 10006230: using guessed type wchar_t aUp6ql[6];
// 10006400: using guessed type wchar_t a08Abcdefjksxyz[48];

//----- (100039B0) --------------------------------------------------------
int __fastcall sub_100039B0(__int16 a1, _WORD *a2)
{
  _WORD *v2; // esi
  int v3; // edi
  int v4; // edx
  int v5; // edx
  int v6; // eax
  int result; // eax

  *a2 = a1;
  v2 = a2 + 1;
  v3 = 9;
  do
  {
    v4 = a1 * (__int16)*(v2 - 1);
    if ( v4 == 0x40000000 )
    {
      dword_10009650 = 1;
      v5 = 0x7FFFFFFF;
    }
    else
    {
      v5 = 2 * v4;
    }
    v6 = v5 + 0x8000;
    if ( v5 >= 0 && (v5 ^ v6) < 0 )
    {
      dword_10009650 = 1;
      v6 = (v5 < 0) + 0x7FFFFFFF;
    }
    result = v6 >> 16;
    *v2++ = result;
    --v3;
  }
  while ( v3 );
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10003A20) --------------------------------------------------------
int __fastcall sub_10003A20(__int16 *a1, _DWORD *a2)
{
  int v2; // ebx
  int *v3; // esi
  __int16 *v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // edi
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // eax
  int v16; // ecx
  int result; // eax
  int v18; // [esp+Ch] [ebp-14h]
  int v19; // [esp+10h] [ebp-10h]
  __int16 *v20; // [esp+14h] [ebp-Ch]
  __int16 v21; // [esp+18h] [ebp-8h] BYREF
  __int16 v22; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 2;
  v18 = 2;
  *a2 = 0x1000000;
  a2[1] = 0;
  a2[1] = -1024 * *a1;
  v3 = a2 + 2;
  v4 = a1 + 2;
  v20 = a1 + 2;
  do
  {
    *v3 = *(v3 - 2);
    if ( (__int16)v2 > 1 )
    {
      v19 = (unsigned __int16)(v2 - 1);
      do
      {
        sub_100010D0(*(v3 - 1), &v22, &v21);
        v5 = *v4;
        v6 = v5 * v22;
        v7 = -2 * (__int16)((unsigned int)(v5 * v21) >> 16);
        v8 = v6 - v7;
        if ( (v6 ^ v7) < 0 && (v6 ^ v8) < 0 )
        {
          dword_10009650 = 1;
          v8 = (v6 < 0) + 0x7FFFFFFF;
        }
        v9 = 1;
        while ( v8 <= 0x3FFFFFFF )
        {
          if ( v8 < -1073741824 )
          {
            v8 = 0x80000000;
            goto LABEL_14;
          }
          --v9;
          v8 *= 2;
          if ( (__int16)v9 <= 0 )
            goto LABEL_15;
        }
        v8 = 0x7FFFFFFF;
LABEL_14:
        dword_10009650 = 1;
LABEL_15:
        v10 = *(v3 - 2);
        v11 = *v3;
        v12 = *v3 + v10;
        if ( (v10 ^ *v3) >= 0 && (v11 ^ v12) < 0 )
        {
          dword_10009650 = 1;
          v12 = (v11 < 0) + 0x7FFFFFFF;
        }
        *v3 = v12;
        v13 = v12 - v8;
        if ( (v8 ^ v12) < 0 && (v12 ^ v13) < 0 )
        {
          dword_10009650 = 1;
          v13 = (v12 < 0) + 0x7FFFFFFF;
        }
        v4 = v20;
        *v3-- = v13;
        --v19;
      }
      while ( v19 );
      v2 = v18;
    }
    v14 = *v3;
    v15 = -1024 * *v4;
    v16 = v15 + *v3;
    if ( (*v3 ^ v15) >= 0 && (v14 ^ v16) < 0 )
    {
      dword_10009650 = 1;
      v16 = (v14 < 0) + 0x7FFFFFFF;
    }
    result = (__int16)v2;
    v4 += 2;
    ++v2;
    *v3 = v16;
    v20 = v4;
    v18 = v2;
    v3 += result;
  }
  while ( (__int16)v2 <= 5 );
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10003BC0) --------------------------------------------------------
int __fastcall sub_10003BC0(int a1, __int16 *a2, _WORD *a3)
{
  int v3; // eax
  __int16 *v4; // esi
  __int16 v5; // dx
  int v6; // ecx
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  bool v15; // zf
  int v17; // [esp+14h] [ebp-2Ch]
  int v18; // [esp+18h] [ebp-28h]
  _WORD *v19; // [esp+1Ch] [ebp-24h]
  int v20; // [esp+20h] [ebp-20h]
  __int16 v22[10]; // [esp+28h] [ebp-18h] BYREF

  LOWORD(v3) = 0x2000;
  v4 = a2;
  v17 = a1 - (_DWORD)a2;
  v5 = 24576;
  v19 = a3;
  v18 = 3;
  do
  {
    v6 = (__int16)v3;
    v7 = 10;
    v8 = v5;
    v20 = (__int16)v3;
    do
    {
      v9 = v8 * *(__int16 *)((char *)v4 + v17);
      v10 = 2 * v9;
      if ( v9 == 0x40000000 )
        v10 = 0x7FFFFFFF;
      v11 = v6 * *v4;
      v12 = 2 * v11;
      if ( v11 == 0x40000000 )
        v12 = 0x7FFFFFFF;
      v13 = v12 + v10;
      if ( (v10 ^ v12) >= 0 && (v10 ^ v13) < 0 )
        v13 = (v10 < 0) + 0x7FFFFFFF;
      *(__int16 *)((char *)v4++ + (char *)v22 - (char *)a2) = HIWORD(v13);
      v6 = v20;
      --v7;
    }
    while ( v7 );
    sub_10003DC0(v22, v19);
    v14 = v8 - 0x2000;
    if ( v8 - 0x2000 <= 0x7FFF )
    {
      if ( v14 < -32768 )
        LOWORD(v14) = 0x8000;
    }
    else
    {
      LOWORD(v14) = 0x7FFF;
    }
    v5 = v14;
    v3 = v20 + 0x2000;
    if ( v20 + 0x2000 <= 0x7FFF )
    {
      if ( v3 >= -32768 )
      {
        dword_10009650 = 0;
      }
      else
      {
        dword_10009650 = 1;
        LOWORD(v3) = 0x8000;
      }
    }
    else
    {
      dword_10009650 = 1;
      LOWORD(v3) = 0x7FFF;
    }
    v15 = v18-- == 1;
    v19 += 11;
    v4 = a2;
  }
  while ( !v15 );
  return sub_10003DC0(a2, a3 + 33);
}
// 10009650: using guessed type int dword_10009650;
// 10003BC0: using guessed type __int16 var_18[10];

//----- (10003D20) --------------------------------------------------------
int __thiscall sub_10003D20(void *this)
{
  __int16 v1; // dx
  unsigned int v2; // eax
  __int16 *v3; // esi
  int v4; // edx
  int v5; // edi
  int v6; // ecx
  int result; // eax
  __int16 v8; // [esp+8h] [ebp-7Ch] BYREF
  char v9[118]; // [esp+Ah] [ebp-7Ah] BYREF

  v1 = 1;
  v8 = 1024;
  do
  {
    v2 = 2 * v1;
    if ( v2 >= 0x78 )
      __report_rangecheckfailure();
    ++v1;
    *(_WORD *)&v9[v2 - 2] = 0;
  }
  while ( v1 < 60 );
  sub_10003FD0((int)this, &v8, (char *)&v8, (int)this, (int)v9, 0);
  v3 = &v8;
  v4 = 0;
  v5 = 60;
  do
  {
    v6 = *v3 * *v3;
    result = v6 + v4;
    if ( (v4 ^ v6) >= 0 && (v4 ^ result) < 0 )
    {
      dword_10009650 = 1;
      result = (v4 < 0) + 0x7FFFFFFF;
    }
    ++v3;
    v4 = result;
    --v5;
  }
  while ( v5 );
  return result;
}
// 10005362: using guessed type void __noreturn __report_rangecheckfailure(void);
// 10009650: using guessed type int dword_10009650;
// 10003D20: using guessed type char var_7A[118];

//----- (10003DC0) --------------------------------------------------------
int __fastcall sub_10003DC0(__int16 *a1, _WORD *a2)
{
  int v3; // ebx
  int v4; // esi
  int v5; // ecx
  int v6; // edi
  int v7; // edx
  int v8; // edi
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  int v12; // edi
  int v13; // esi
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int result; // eax
  int v19; // ecx
  bool v20; // zf
  int v22; // [esp+10h] [ebp-3Ch]
  _WORD *v23; // [esp+14h] [ebp-38h]
  _DWORD v24[6]; // [esp+18h] [ebp-34h] BYREF
  _DWORD v25[6]; // [esp+30h] [ebp-1Ch] BYREF

  sub_10003A20(a1, v24);
  sub_10003A20(a1 + 1, v25);
  v3 = 5;
  v4 = 0;
  do
  {
    v5 = v24[v4 + 4];
    v6 = v24[v4 + 5];
    v7 = v6 + v5;
    if ( (v5 ^ v6) >= 0 && (v6 ^ v7) < 0 )
    {
      dword_10009650 = 1;
      v7 = (v6 < 0) + 0x7FFFFFFF;
    }
    v8 = v25[v4 + 5];
    v9 = v25[v4 + 4];
    v24[v4 + 5] = v7;
    v10 = v8 - v9;
    if ( (v9 ^ v8) < 0 && (v8 ^ v10) < 0 )
    {
      dword_10009650 = 1;
      v10 = (v8 < 0) + 0x7FFFFFFF;
    }
    v25[v4 + 5] = v10;
    --v3;
    --v4;
  }
  while ( (__int16)v3 > 0 );
  v11 = 10;
  v22 = 5;
  *a2 = 4096;
  v23 = a2 + 1;
  v12 = 0;
  do
  {
    v13 = v25[v12 + 1];
    v14 = v24[v12 + 1];
    v15 = v14 + v13;
    if ( (v13 ^ v14) >= 0 && (v14 ^ v15) < 0 )
    {
      dword_10009650 = 1;
      v15 = (v14 < 0) + 0x7FFFFFFF;
    }
    if ( v15 >= 0 )
      v16 = v15 >> 13;
    else
      v16 = ~(~v15 >> 13);
    if ( (v15 & 0x1000) != 0 )
      LOWORD(v16) = v16 + 1;
    *v23 = v16;
    v17 = v14 - v13;
    if ( (v14 ^ v13) < 0 && (v14 ^ v17) < 0 )
    {
      dword_10009650 = 1;
      v17 = (v14 < 0) + 0x7FFFFFFF;
    }
    if ( v17 >= 0 )
      result = v17 >> 13;
    else
      result = ~(~v17 >> 13);
    if ( (v17 & 0x1000) != 0 )
      ++result;
    ++v12;
    ++v23;
    v19 = (__int16)v11--;
    v20 = v22-- == 1;
    a2[v19] = result;
  }
  while ( !v20 );
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10003F40) --------------------------------------------------------
int __fastcall sub_10003F40(char *a1, __int16 *a2, _WORD *a3)
{
  __int16 v3; // ax
  int v6; // ecx
  _WORD *v7; // edi
  int v8; // esi
  int v9; // edx
  int v10; // edx
  int v11; // eax
  int result; // eax
  int v13; // [esp+14h] [ebp+8h]

  v3 = *(_WORD *)a1;
  v6 = a1 - (char *)a3;
  v13 = v6;
  *a3 = v3;
  v7 = a3 + 1;
  v8 = 10;
  do
  {
    v9 = *a2 * *(__int16 *)((char *)v7 + v6);
    if ( v9 == 0x40000000 )
    {
      dword_10009650 = 1;
      v10 = 0x7FFFFFFF;
    }
    else
    {
      v10 = 2 * v9;
    }
    v11 = v10 + 0x8000;
    if ( v10 >= 0 )
    {
      v6 = v13;
      if ( (v10 ^ v11) < 0 )
      {
        dword_10009650 = 1;
        v11 = (v10 < 0) + 0x7FFFFFFF;
      }
    }
    result = v11 >> 16;
    ++a2;
    *v7++ = result;
    --v8;
  }
  while ( v8 );
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10003FD0) --------------------------------------------------------
__int16 __fastcall sub_10003FD0(int a1, __int16 *a2, char *a3, int a4, int a5, __int16 a6)
{
  __int16 *v6; // ecx
  char *v7; // ebx
  int v8; // eax
  int v9; // edx
  char *v10; // edi
  __int16 *v11; // esi
  int v12; // ebx
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  bool v17; // zf
  __int16 result; // ax
  _WORD *v19; // ebx
  __int16 *v20; // ecx
  int v21; // edx
  __int16 *v22; // [esp+10h] [ebp-B4h]
  char *v23; // [esp+14h] [ebp-B0h]
  int v24; // [esp+18h] [ebp-ACh]
  __int16 *v25; // [esp+1Ch] [ebp-A8h]
  int v26; // [esp+30h] [ebp-94h]
  char v27[140]; // [esp+34h] [ebp-90h] BYREF

  v6 = (__int16 *)(a1 + 2);
  v7 = v27;
  v25 = a2;
  v26 = *(_DWORD *)(a5 + 16);
  v23 = v27;
  v22 = v6;
  v24 = 60;
  do
  {
    v8 = -4096 * *a2;
    v9 = *a2 << 12;
    if ( v8 < 0 && v9 < 0 )
    {
      v9 = 0x7FFFFFFF;
      dword_10009650 = 1;
    }
    v10 = v7 - 2;
    v11 = v6;
    v12 = 10;
    do
    {
      v13 = *v11 * *(__int16 *)v10;
      v14 = v9 - v13;
      if ( (v9 ^ v13) < 0 && (v9 ^ v14) < 0 )
      {
        dword_10009650 = 1;
        v14 = (v9 < 0) + 0x7FFFFFFF;
      }
      v10 -= 2;
      ++v11;
      v9 = v14;
      --v12;
    }
    while ( v12 );
    v15 = v14 + 2048;
    if ( v14 >= 0 && (v14 ^ v15) < 0 )
    {
      dword_10009650 = 1;
      v15 = (v14 < 0) + 0x7FFFFFFF;
    }
    v16 = 4;
    while ( v15 <= 0x3FFFFFFF )
    {
      if ( v15 < -1073741824 )
      {
        HIWORD(v15) = 0x8000;
        goto LABEL_20;
      }
      --v16;
      v15 *= 2;
      if ( (__int16)v16 <= 0 )
        goto LABEL_21;
    }
    HIWORD(v15) = 0x7FFF;
LABEL_20:
    dword_10009650 = 1;
LABEL_21:
    v6 = v22;
    *(_WORD *)v23 = HIWORD(v15);
    v7 = v23 + 2;
    a2 = v25 + 1;
    v23 += 2;
    v17 = v24-- == 1;
    ++v25;
  }
  while ( !v17 );
  result = (__int16)a3;
  qmemcpy(a3, v27, 0x78u);
  if ( a6 )
  {
    v19 = (_WORD *)a5;
    v20 = (__int16 *)(a3 + 100);
    v21 = 10;
    do
    {
      result = *v20++;
      *v19++ = result;
      --v21;
    }
    while ( v21 );
  }
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10004180) --------------------------------------------------------
int __fastcall sub_10004180(__int16 *a1, _WORD *a2)
{
  __int16 v2; // ax
  _WORD *v3; // ecx
  __int16 *v4; // ebx
  int v5; // edi
  __int16 v6; // dx
  __int16 *v7; // esi
  int v8; // edi
  int v9; // eax
  __int16 v10; // cx
  __int16 v11; // ax
  int result; // eax
  int v13; // [esp+Ch] [ebp-14h]
  int v14; // [esp+14h] [ebp-Ch]
  const wchar_t *v15; // [esp+18h] [ebp-8h]
  _WORD *v16; // [esp+1Ch] [ebp-4h]

  v2 = *a1;
  v3 = a1 + 1;
  *a2 = v2;
  v4 = asc_10006680;
  v16 = v3;
  v15 = asc_10006680;
  v5 = 23;
  v13 = (char *)(a2 + 1) - (char *)asc_10006680;
  v14 = 23;
  do
  {
    v6 = 0;
    v7 = v3;
    if ( *v4 > 0 )
    {
      v8 = (unsigned __int16)*v4;
      do
      {
        v9 = 2 * v6;
        if ( v9 != (__int16)v9 )
        {
          dword_10009650 = 1;
          LOWORD(v9) = 0x8000;
          if ( v6 > 0 )
            LOWORD(v9) = 0x7FFF;
        }
        v10 = v9;
        v11 = *v7++;
        v6 = v10;
        if ( v11 == 1 )
          v6 = v10 + 1;
        --v8;
      }
      while ( v8 );
      v4 = (__int16 *)v15;
      v3 = v16;
      v5 = v14;
    }
    *(__int16 *)((char *)v4 + v13) = v6;
    LOWORD(result) = *v4++;
    result = (__int16)result;
    --v5;
    v15 = (const wchar_t *)v4;
    v14 = v5;
    v3 += (__int16)result;
    v16 = v3;
  }
  while ( v5 );
  return result;
}
// 10006680: using guessed type wchar_t asc_10006680[4];
// 10009650: using guessed type int dword_10009650;

//----- (10004230) --------------------------------------------------------
__int16 __fastcall sub_10004230(
        __int16 a1,
        __int16 a2,
        void *a3,
        __int16 *a4,
        __int16 *a5,
        int a6,
        __int16 *a7,
        _WORD *a8,
        __int16 *a9,
        __int16 *a10)
{
  int v10; // eax
  int v11; // esi
  int i; // edi
  int v13; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  __int16 j; // si
  int v21; // edx
  int v22; // eax
  __int16 v23; // dx
  int v24; // ebx
  int v25; // ecx
  int v26; // eax
  int v27; // ecx
  __int16 v28; // si
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // ecx
  int v38; // edx
  int v39; // edi
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // edx
  int v44; // eax
  int v45; // ecx
  int v46; // eax
  int v47; // edx
  int v48; // ebx
  int v50; // eax
  int v51; // eax
  __int16 *v52; // edi
  int v53; // eax
  __int16 v54; // ax
  int v55; // ecx
  int v56; // eax
  int v57; // edx
  int v58; // ecx
  int v59; // edx
  int v60; // eax
  int v61; // ecx
  int v62; // edx
  int v63; // edx
  __int16 v64; // ax
  int v65; // ecx
  __int16 v66; // ax
  int v67; // ecx
  __int16 v68; // ax
  int v69; // eax
  int v70; // eax
  int v71; // edx
  int v72; // eax
  int v73; // ecx
  int v74; // esi
  int v75; // eax
  __int16 v76; // si
  int v77; // edx
  int v78; // edx
  int v79; // eax
  int v80; // ecx
  int v82; // [esp+Ch] [ebp-14h]
  __int16 v83; // [esp+10h] [ebp-10h]
  __int16 v84; // [esp+10h] [ebp-10h]
  int v85; // [esp+14h] [ebp-Ch] BYREF
  int v86; // [esp+18h] [ebp-8h] BYREF
  __int16 v87; // [esp+1Ch] [ebp-4h]
  __int16 v88; // [esp+1Eh] [ebp-2h]
  int v89; // [esp+40h] [ebp+20h]
  int v90; // [esp+44h] [ebp+24h]

  v88 = a1;
  v87 = a2;
  v10 = sub_10003D20(a3);
  v11 = v10;
  if ( v10 )
  {
    if ( v10 == -1 )
    {
      i = 31;
    }
    else
    {
      if ( v10 < 0 )
        v11 = ~v10;
      for ( i = 0; v11 < 0x40000000; ++i )
        v11 *= 2;
    }
  }
  else
  {
    i = 0;
  }
  v13 = sub_100050F0(v10, i);
  v15 = 1;
  v83 = HIWORD(v13);
  v16 = 60;
  do
  {
    v17 = *a4 * *a4;
    v18 = v17 + v15;
    if ( (v15 ^ v17) >= 0 && (v15 ^ v18) < 0 )
      v18 = (v15 < 0) + 0x7FFFFFFF;
    ++a4;
    v15 = v18;
    --v16;
  }
  while ( v16 );
  v19 = v18;
  if ( !v18 )
  {
    j = 0;
LABEL_27:
    v23 = -j;
    if ( (__int16)-j < 31 )
    {
      if ( v18 >= 0 )
        v22 = v18 >> v23;
      else
        HIWORD(v22) = ~((unsigned int)(~v18 >> v23) >> 16);
    }
    else
    {
      v22 = (v18 >= 0) - 1;
    }
    goto LABEL_34;
  }
  if ( v18 == -1 )
  {
    j = 31;
    v21 = 31;
    goto LABEL_18;
  }
  if ( v18 < 0 )
    v19 = ~v18;
  for ( j = 0; v19 < 0x40000000; ++j )
    v19 *= 2;
  v21 = (unsigned __int16)j;
  if ( j <= 0 )
    goto LABEL_27;
LABEL_18:
  while ( v18 <= 0x3FFFFFFF )
  {
    if ( v18 < -1073741824 )
    {
      HIWORD(v22) = 0x8000;
      goto LABEL_34;
    }
    v18 *= 2;
    --v21;
    HIWORD(v22) = HIWORD(v18);
    if ( (__int16)v21 <= 0 )
      goto LABEL_34;
  }
  HIWORD(v22) = 0x7FFF;
LABEL_34:
  v24 = v83;
  v25 = SHIWORD(v22);
  v26 = (__int16)i + j;
  v27 = v83 * v25;
  v82 = (__int16)i;
  if ( v26 <= 0x7FFF )
  {
    v28 = 0x8000;
    if ( v26 >= -32768 )
      v28 = v26;
  }
  else
  {
    v28 = 0x7FFF;
  }
  sub_10001160(v27, &v85, &v86);
  if ( -32768 * (__int16)v85 == 0x40000000 )
    v29 = 0x7FFFFFFF;
  else
    v29 = -65536 * (__int16)v85;
  v30 = -v29;
  v31 = -2 * (__int16)v86;
  v32 = v30 - v31;
  if ( (v30 ^ v31) < 0 && (v30 ^ v32) < 0 )
    v32 = (v30 < 0) + 0x7FFFFFFF;
  if ( -32768 * v28 == 0x40000000 )
    v33 = 0x7FFFFFFF;
  else
    v33 = -65536 * v28;
  v34 = v33 + v32;
  if ( (v32 ^ v33) >= 0 && (v32 ^ v34) < 0 )
    v34 = (v32 < 0) + 0x7FFFFFFF;
  v35 = v34 + 437760;
  if ( v34 >= 0 && (v34 ^ v35) < 0 )
    v35 = (v34 < 0) + 0x7FFFFFFF;
  if ( v35 >= 0 )
    v36 = v35 >> 8;
  else
    v36 = ~(~v35 >> 8);
  v38 = 0;
  v84 = v36;
  v39 = 60;
  do
  {
    v40 = *a5 * *a5;
    v41 = v40 + v38;
    if ( (v38 ^ v40) >= 0 && (v38 ^ v41) < 0 )
      v41 = (v38 < 0) + 0x7FFFFFFF;
    ++a5;
    v38 = v41;
    --v39;
  }
  while ( v39 );
  sub_10001160(v24 * SHIWORD(v41), &v85, &v86);
  if ( -32768 * (__int16)v85 == 0x40000000 )
    v42 = 0x7FFFFFFF;
  else
    v42 = -65536 * (__int16)v85;
  v43 = -v42;
  v44 = -2 * (__int16)v86;
  v45 = v43 - v44;
  if ( (v43 ^ v44) < 0 && (v43 ^ v45) < 0 )
    v45 = (v43 < 0) + 0x7FFFFFFF;
  if ( -32768 * v82 == 0x40000000 )
    v46 = 0x7FFFFFFF;
  else
    v46 = -65536 * v82;
  v47 = v46 + v45;
  if ( (v45 ^ v46) >= 0 && (v45 ^ v47) < 0 )
    v47 = (v45 < 0) + 0x7FFFFFFF;
  v48 = v47 - 1135104;
  if ( v47 < 0 && (v47 ^ v48) < 0 )
    v48 = (v47 < 0) + 0x7FFFFFFF;
  if ( v48 >= 0 )
    v48 >>= 8;
  else
    LOWORD(v48) = ~(unsigned __int16)(~v48 >> 8);
  v50 = *a9;
  if ( !v87 )
  {
    v55 = v50 << 8;
    v52 = a10;
    v56 = -128 * *a10;
    v57 = v55 - v56;
    if ( (v55 ^ v56) < 0 && (v55 ^ v57) < 0 )
      v57 = (v55 < 0) + 0x7FFFFFFF;
    v58 = v57 - 393216;
    if ( v57 < 0 && (v57 ^ v58) < 0 )
      v58 = (v57 < 0) + 0x7FFFFFFF;
    if ( v58 < 0 )
      v58 = 0;
    v89 = v58 >> 9;
    v59 = *a10 << 8;
    if ( -256 * *a10 < 0 && (*a10 & 0x800000) != 0 )
      v59 = 0x7FFFFFFF;
    v60 = -128 * *a9;
    v61 = v59 - v60;
    if ( (v59 ^ v60) < 0 && (v59 ^ v61) < 0 )
      v61 = (v59 < 0) + 0x7FFFFFFF;
    v62 = v61 - 393216;
    if ( v61 < 0 && (v61 ^ v62) < 0 )
      v62 = (v61 < 0) + 0x7FFFFFFF;
    if ( v62 < 0 )
      v62 = 0;
    v63 = v62 >> 9;
    if ( 2 * v88 == (__int16)(2 * v88) )
    {
      v64 = 2 * v88;
    }
    else
    {
      v64 = 0x8000;
      if ( v88 > 0 )
        v64 = 0x7FFF;
    }
    v90 = v64;
    v65 = (__int16)v89 + word_10007618[v90];
    if ( v65 <= 0x7FFF )
    {
      v66 = 0x8000;
      if ( v65 >= -32768 )
        v66 = v89 + word_10007618[v90];
    }
    else
    {
      v66 = 0x7FFF;
    }
    *a9 = v66;
    v67 = (__int16)v63 + word_1000761A[v90];
    if ( v67 <= 0x7FFF )
    {
      v68 = 0x8000;
      if ( v67 >= -32768 )
        v68 = v63 + word_1000761A[v90];
    }
    else
    {
      v68 = 0x7FFF;
    }
    *v52 = v68;
    v69 = *a9 - 6912;
    if ( v69 > 0x7FFF || v69 >= -32768 && (__int16)v69 > 0 )
      *a9 = 6912;
    v70 = *v52 - 6400;
    if ( v70 <= 0x7FFF )
    {
      if ( v70 < -32768 )
      {
        dword_10009650 = 1;
        goto LABEL_135;
      }
      dword_10009650 = 0;
      if ( (__int16)v70 <= 0 )
        goto LABEL_135;
    }
    else
    {
      dword_10009650 = 1;
    }
    v54 = 6400;
    goto LABEL_134;
  }
  v51 = v50 - 128;
  if ( v51 > 0x7FFF )
  {
    *a9 = 0x7FFF;
    goto LABEL_86;
  }
  if ( v51 >= -32768 )
  {
    *a9 = v51;
    if ( (v51 & 0x8000u) == 0 )
      goto LABEL_86;
  }
  else
  {
    *a9 = 0x8000;
  }
  *a9 = 0;
LABEL_86:
  v52 = a10;
  v53 = *a10 - 128;
  if ( v53 <= 0x7FFF )
  {
    if ( v53 >= -32768 )
    {
      dword_10009650 = 0;
      *a10 = v53;
      if ( (v53 & 0x8000u) == 0 )
        goto LABEL_135;
      v54 = 0;
    }
    else
    {
      dword_10009650 = 1;
      v54 = 0;
      *a10 = 0x8000;
    }
LABEL_134:
    *v52 = v54;
    goto LABEL_135;
  }
  dword_10009650 = 1;
  *a10 = 0x7FFF;
LABEL_135:
  v71 = *a9 << 6;
  if ( -64 * *a9 < 0 && (*a9 & 0x2000000) != 0 )
  {
    v71 = 0x7FFFFFFF;
    dword_10009650 = 1;
  }
  v72 = -64 * v84;
  v73 = v72 + v71;
  if ( (v71 ^ v72) >= 0 && (v71 ^ v73) < 0 )
  {
    dword_10009650 = 1;
    v73 = (v71 < 0) + 0x7FFFFFFF;
  }
  v74 = v73 + 393216;
  if ( v73 >= 0 && (v73 ^ v74) < 0 )
  {
    dword_10009650 = 1;
    v74 = (v73 < 0) + 0x7FFFFFFF;
  }
  sub_100010D0(v74, &v85, &v86);
  v75 = sub_100012D0(v85, v86);
  v76 = v75;
  v77 = v75 - 4915;
  if ( v75 < 0 && (v75 ^ v77) < 0 )
  {
    dword_10009650 = 1;
    v77 = (v75 < 0) + 0x7FFFFFFF;
  }
  if ( v77 > 0 )
    v76 = 4915;
  *a7 = v76;
  v78 = *v52 << 6;
  if ( -64 * *v52 < 0 && (*v52 & 0x2000000) != 0 )
  {
    v78 = 0x7FFFFFFF;
    dword_10009650 = 1;
  }
  v79 = -64 * (__int16)v48;
  v80 = v79 + v78;
  if ( (v78 ^ v79) >= 0 && (v78 ^ v80) < 0 )
  {
    dword_10009650 = 1;
    v80 = (v78 < 0) + 0x7FFFFFFF;
  }
  sub_100010D0(v80, &v85, &v86);
  *a8 = sub_100012D0(v85, v86);
  return v88;
}
// 1000432C: conditional instruction was optimized away because si.2<1
// 100043DA: conditional instruction was optimized away because eax.4<0
// 100044DD: conditional instruction was optimized away because eax.4<0
// 10004612: conditional instruction was optimized away because eax.4<0
// 10007618: using guessed type __int16 word_10007618[];
// 1000761A: using guessed type __int16 word_1000761A[];
// 10009650: using guessed type int dword_10009650;

//----- (10004920) --------------------------------------------------------
int __fastcall sub_10004920(__int16 a1, __int16 a2, __int16 a3, int a4, int a5)
{
  __int16 v5; // ax
  __int16 v6; // bx
  int v7; // eax
  __int16 v8; // dx
  int v9; // eax
  __int16 v10; // di
  int v11; // eax
  __int16 v12; // si
  int v13; // ecx
  __int16 *v14; // edx
  int v15; // eax
  int v16; // edi
  int v17; // ebx
  int v18; // ecx
  int v19; // esi
  bool v20; // zf
  int v21; // esi
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ebx
  int v26; // eax
  int v27; // ecx
  int result; // eax
  int v29; // esi
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // ebx
  int v34; // ecx
  int v35; // eax
  int v36; // eax
  int v37; // [esp+Ch] [ebp-8h]
  int v38; // [esp+Ch] [ebp-8h]
  int v39; // [esp+10h] [ebp-4h]
  int v41; // [esp+1Ch] [ebp+8h]
  int v42; // [esp+1Ch] [ebp+8h]
  int v43; // [esp+20h] [ebp+Ch]

  if ( 2 * (a1 & 0x1F) == (__int16)(2 * (a1 & 0x1F)) )
  {
    v6 = 2 * (a1 & 0x1F);
  }
  else
  {
    v5 = 0x8000;
    if ( (a1 & 0x1F) != 0 )
      v5 = 0x7FFF;
    v6 = v5;
  }
  v7 = ((a1 & 0xE0) >> 2) + 2;
  if ( v7 <= 0x7FFF )
  {
    v8 = 0x8000;
    if ( v7 >= -32768 )
      v8 = ((a1 & 0xE0) >> 2) + 2;
  }
  else
  {
    v8 = 0x7FFF;
  }
  v9 = ((a1 & 0x700) >> 5) + 4;
  if ( v9 <= 0x7FFF )
  {
    v10 = 0x8000;
    if ( v9 >= -32768 )
      v10 = ((a1 & 0x700) >> 5) + 4;
  }
  else
  {
    v10 = 0x7FFF;
  }
  v11 = ((a1 & 0x3800) >> 8) + 6;
  if ( v11 <= 0x7FFF )
  {
    if ( v11 >= -32768 )
    {
      dword_10009650 = 0;
      v12 = ((a1 & 0x3800) >> 8) + 6;
    }
    else
    {
      dword_10009650 = 1;
      v12 = 0x8000;
    }
  }
  else
  {
    dword_10009650 = 1;
    v12 = 0x7FFF;
  }
  v13 = a4 - 2 * a3;
  v41 = v13 - 2 * v6;
  v14 = (__int16 *)(v13 - 2 * v8);
  v15 = 2 * v10;
  v16 = 60;
  v17 = v13 - v15 - (_DWORD)v14;
  v18 = v13 - 2 * v12 - (_DWORD)v14;
  v19 = v41 - (_DWORD)v14;
  v43 = v18;
  v42 = v41 - (_DWORD)v14;
  v20 = a2 == 0;
  v39 = v17;
  if ( !v20 )
  {
    v38 = a5 - (_DWORD)v14;
    while ( 1 )
    {
      v29 = 2896 * *(__int16 *)((char *)v14 + v19);
      v30 = -2048 * *v14;
      v31 = v30 + v29;
      if ( (v29 ^ v30) >= 0 && (v29 ^ v31) < 0 )
      {
        dword_10009650 = 1;
        v31 = (v29 < 0) + 0x7FFFFFFF;
      }
      v32 = -2048 * *(__int16 *)((char *)v14 + v17);
      v33 = v31 - v32;
      if ( (v31 ^ v32) < 0 && (v31 ^ v33) < 0 )
      {
        dword_10009650 = 1;
        v33 = (v31 < 0) + 0x7FFFFFFF;
      }
      v34 = -2048 * *(__int16 *)((char *)v14 + v43);
      v35 = v34 + v33;
      if ( (v33 ^ v34) >= 0 && (v33 ^ v35) < 0 )
      {
        dword_10009650 = 1;
        v35 = (v33 < 0) + 0x7FFFFFFF;
      }
      if ( v35 == 0x80000000 )
      {
        v36 = 0x7FFFFFFF;
      }
      else
      {
        v36 = -v35;
        if ( v36 < 0 )
        {
          result = ~(~v36 >> 11);
          goto LABEL_48;
        }
      }
      result = v36 >> 11;
LABEL_48:
      v17 = v39;
      v19 = v42;
      *(__int16 *)((char *)v14++ + v38) = result;
      if ( !--v16 )
        return result;
    }
  }
  v37 = a5 - (_DWORD)v14;
  do
  {
    v21 = 2896 * *(__int16 *)((char *)v14 + v19);
    v22 = -2048 * *v14;
    v23 = v22 + v21;
    if ( (v21 ^ v22) >= 0 && (v21 ^ v23) < 0 )
    {
      dword_10009650 = 1;
      v23 = (v21 < 0) + 0x7FFFFFFF;
    }
    v24 = -2048 * *(__int16 *)((char *)v14 + v17);
    v25 = v23 - v24;
    if ( (v23 ^ v24) < 0 && (v23 ^ v25) < 0 )
    {
      dword_10009650 = 1;
      v25 = (v23 < 0) + 0x7FFFFFFF;
    }
    v26 = -2048 * *(__int16 *)((char *)v14 + v43);
    v27 = v26 + v25;
    if ( (v25 ^ v26) >= 0 && (v25 ^ v27) < 0 )
    {
      dword_10009650 = 1;
      v27 = (v25 < 0) + 0x7FFFFFFF;
    }
    if ( v27 >= 0 )
      v27 >>= 11;
    else
      LOWORD(v27) = ~(unsigned __int16)(~v27 >> 11);
    result = v37;
    v17 = v39;
    v19 = v42;
    *(__int16 *)((char *)v14++ + v37) = v27;
    --v16;
  }
  while ( v16 );
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10004C30) --------------------------------------------------------
__int16 __fastcall sub_10004C30(__int16 *a1, __int16 *a2, int a3)
{
  __int16 *v4; // esi
  __int16 *v5; // ecx
  int v6; // eax
  int v7; // edi
  __int16 *v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  __int16 v12; // si
  int v13; // esi
  int v14; // eax
  int v15; // ecx
  __int16 v16; // ax
  int v17; // edi
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  __int16 v21; // si
  int v22; // esi
  int v23; // eax
  int v24; // ecx
  __int16 v25; // ax
  __int16 v26; // bx
  __int16 *v27; // eax
  int v28; // edi
  int v29; // ecx
  int v30; // ecx
  int v31; // esi

  v4 = (__int16 *)((char *)&unk_10007018 + 6 * *a1);
  *a2 = *v4;
  a2[1] = v4[1];
  a2[2] = v4[2];
  v5 = (__int16 *)((char *)&unk_10007718 + 6 * a1[1]);
  a2[3] = *v5;
  a2[4] = v5[1];
  a2[5] = v5[2];
  v6 = a1[2];
  v7 = a2[2];
  v8 = (__int16 *)((char *)&unk_10008318 + 8 * v6);
  a2[6] = *v8;
  a2[7] = v8[1];
  a2[8] = v8[2];
  a2[9] = v8[3];
  v9 = 917 - v7;
  if ( 917 - v7 <= 0x7FFF )
  {
    if ( v9 < -32768 )
      LOWORD(v9) = 0x8000;
  }
  else
  {
    LOWORD(v9) = 0x7FFF;
  }
  v10 = a2[3];
  v11 = v10 + (__int16)v9;
  if ( v11 <= 0x7FFF )
  {
    if ( v11 < -32768 )
      goto LABEL_18;
    v12 = v11;
    if ( (__int16)v11 <= 0 )
      goto LABEL_18;
  }
  else
  {
    v12 = 0x7FFF;
  }
  v13 = v12 >> 1;
  v14 = v13 + v7;
  if ( v13 + v7 <= 0x7FFF )
  {
    if ( v14 < -32768 )
      LOWORD(v14) = 0x8000;
  }
  else
  {
    LOWORD(v14) = 0x7FFF;
  }
  v15 = v10 - v13;
  a2[2] = v14;
  if ( v15 <= 0x7FFF )
  {
    v16 = 0x8000;
    if ( v15 >= -32768 )
      v16 = v15;
  }
  else
  {
    v16 = 0x7FFF;
  }
  a2[3] = v16;
LABEL_18:
  v17 = a2[5];
  v18 = 1245 - v17;
  if ( 1245 - v17 <= 0x7FFF )
  {
    if ( v18 < -32768 )
      LOWORD(v18) = 0x8000;
  }
  else
  {
    LOWORD(v18) = 0x7FFF;
  }
  v19 = a2[6];
  v20 = v19 + (__int16)v18;
  if ( v20 > 0x7FFF )
  {
    v21 = 0x7FFF;
LABEL_26:
    v22 = v21 >> 1;
    v23 = v22 + v17;
    if ( v22 + v17 <= 0x7FFF )
    {
      if ( v23 < -32768 )
        LOWORD(v23) = 0x8000;
    }
    else
    {
      LOWORD(v23) = 0x7FFF;
    }
    v24 = v19 - v22;
    a2[5] = v23;
    if ( v24 <= 0x7FFF )
    {
      v25 = 0x8000;
      if ( v24 >= -32768 )
        v25 = v24;
    }
    else
    {
      v25 = 0x7FFF;
    }
    a2[6] = v25;
    goto LABEL_35;
  }
  if ( v20 >= -32768 )
  {
    v21 = v20;
    if ( (__int16)v20 > 0 )
      goto LABEL_26;
  }
LABEL_35:
  v26 = 0;
  v27 = a2;
  v28 = 9;
  do
  {
    v29 = *v27 - v27[1];
    if ( v29 > 0x7FFF )
    {
      dword_10009650 = 1;
      goto LABEL_42;
    }
    if ( v29 >= -32768 )
    {
      dword_10009650 = 0;
      if ( (__int16)v29 > 0 )
        goto LABEL_42;
    }
    else
    {
      dword_10009650 = 1;
    }
    v26 = 1;
LABEL_42:
    ++v27;
    --v28;
  }
  while ( v28 );
  if ( v26 )
  {
    v30 = 10;
    v31 = a3 - (_DWORD)a2;
    do
    {
      LOWORD(v27) = *(__int16 *)((char *)a2++ + v31);
      *(a2 - 1) = (__int16)v27;
      --v30;
    }
    while ( v30 );
  }
  return (__int16)v27;
}
// 10009650: using guessed type int dword_10009650;

//----- (10004E70) --------------------------------------------------------
__int16 __thiscall sub_10004E70(char *this)
{
  int v1; // edx
  __int16 *v2; // esi
  char *v3; // edi
  int v4; // ebx
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // ecx

  v1 = 0;
  v2 = (__int16 *)&unk_10006640;
  v3 = this - 30;
  v4 = 32;
  do
  {
    v5 = *v2 * *(__int16 *)v3;
    v6 = v5 + v1;
    if ( (v1 ^ v5) >= 0 && (v1 ^ v6) < 0 )
    {
      dword_10009650 = 1;
      v6 = (v1 < 0) + 0x7FFFFFFF;
    }
    v3 += 2;
    ++v2;
    v1 = v6;
    --v4;
  }
  while ( v4 );
  v7 = 2 * v6;
  if ( ((2 * v6) ^ v6) < 0 )
  {
    dword_10009650 = 1;
    v7 = (v6 < 0) + 0x7FFFFFFF;
  }
  v8 = v7 + 0x8000;
  if ( v7 >= 0 && (v7 ^ v8) < 0 )
  {
    dword_10009650 = 1;
    v8 = (v7 < 0) + 0x7FFFFFFF;
  }
  return HIWORD(v8);
}
// 10009650: using guessed type int dword_10009650;

//----- (10004F10) --------------------------------------------------------
__int16 __thiscall sub_10004F10(char *this)
{
  int v1; // edx
  __int16 *v2; // esi
  char *v3; // edi
  int v4; // ebx
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // ecx

  v1 = 0;
  v2 = (__int16 *)&unk_10006600;
  v3 = this - 32;
  v4 = 32;
  do
  {
    v5 = *v2 * *(__int16 *)v3;
    v6 = v5 + v1;
    if ( (v1 ^ v5) >= 0 && (v1 ^ v6) < 0 )
    {
      dword_10009650 = 1;
      v6 = (v1 < 0) + 0x7FFFFFFF;
    }
    v3 += 2;
    ++v2;
    v1 = v6;
    --v4;
  }
  while ( v4 );
  v7 = 2 * v6;
  if ( ((2 * v6) ^ v6) < 0 )
  {
    dword_10009650 = 1;
    v7 = (v6 < 0) + 0x7FFFFFFF;
  }
  v8 = v7 + 0x8000;
  if ( v7 >= 0 && (v7 ^ v8) < 0 )
  {
    dword_10009650 = 1;
    v8 = (v7 < 0) + 0x7FFFFFFF;
  }
  return HIWORD(v8);
}
// 10009650: using guessed type int dword_10009650;

//----- (10004FB0) --------------------------------------------------------
int __fastcall sub_10004FB0(__int16 *a1)
{
  int v1; // edx
  int result; // eax

  v1 = 240;
  do
  {
    result = 2 * *a1;
    if ( result <= 0x7FFF )
    {
      if ( result >= -32768 )
      {
        dword_10009650 = 0;
        result = (unsigned __int16)result;
      }
      else
      {
        dword_10009650 = 1;
        result = -32768;
      }
    }
    else
    {
      dword_10009650 = 1;
      result = 0x7FFF;
    }
    *a1++ = result;
    --v1;
  }
  while ( v1 );
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10005010) --------------------------------------------------------
__int16 __fastcall sub_10005010(_WORD *a1, __int16 a2, __int16 a3)
{
  _WORD *v3; // esi
  int v4; // eax
  int v5; // edx
  _WORD *v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  char *v10; // edi
  int v11; // ebx
  char *v12; // edi

  v3 = a1;
  if ( a3 )
  {
    v8 = a3 - 1;
    if ( v8 <= 0x7FFF && v8 >= -32768 && (dword_10009650 = 0, a3 == 1) )
    {
      v9 = 60;
      v10 = (char *)&a1[-a2];
      do
      {
        LOWORD(v7) = sub_10004F10(v10);
        v10 += 2;
        *v3++ = v7;
        --v9;
      }
      while ( v9 );
    }
    else
    {
      v7 = a3 + 1;
      if ( v7 <= 0x7FFF && v7 >= -32768 )
      {
        dword_10009650 = 0;
        if ( !(_WORD)v7 )
        {
          v11 = 60;
          v12 = (char *)&a1[-a2];
          do
          {
            LOWORD(v7) = sub_10004E70(v12);
            v12 += 2;
            *v3++ = v7;
            --v11;
          }
          while ( v11 );
        }
      }
      else
      {
        dword_10009650 = 1;
      }
    }
  }
  else
  {
    v4 = a2;
    v5 = 60;
    v6 = &a1[-v4];
    do
    {
      LOWORD(v7) = *v6++;
      *v3++ = v7;
      --v5;
    }
    while ( v5 );
  }
  return v7;
}
// 10009650: using guessed type int dword_10009650;

//----- (100050F0) --------------------------------------------------------
int __fastcall sub_100050F0(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  while ( (__int16)a2 <= 0 )
  {
    v2 = (unsigned __int16)-(__int16)a2;
    if ( (v2 & 0x8000u) == 0 )
    {
      if ( (__int16)v2 >= 31 )
        return (a1 >= 0) - 1;
      if ( a1 >= 0 )
        return a1 >> v2;
      return ~(~a1 >> v2);
    }
    a2 = -v2;
  }
  while ( a1 <= 0x3FFFFFFF )
  {
    if ( a1 < -1073741824 )
    {
      result = 0x80000000;
      dword_10009650 = 1;
      return result;
    }
    --a2;
    a1 *= 2;
    if ( (__int16)a2 <= 0 )
      return a1;
  }
  result = 0x7FFFFFFF;
  dword_10009650 = 1;
  return result;
}
// 10009650: using guessed type int dword_10009650;

//----- (10005170) --------------------------------------------------------
int __fastcall sub_10005170(__int16 a1, __int16 a2)
{
  __int16 v4; // cx
  int result; // eax
  int v6; // edx

  if ( a2 >= 0 )
  {
    v6 = a1 * (1 << a2);
    if ( (a2 <= 15 || !a1) && v6 == (__int16)v6 )
    {
      return (unsigned __int16)v6;
    }
    else
    {
      dword_10009650 = 1;
      LOWORD(result) = 0x8000;
      if ( a1 > 0 )
        LOWORD(result) = 0x7FFF;
      return (unsigned __int16)result;
    }
  }
  else
  {
    v4 = -a2;
    if ( (__int16)-a2 < 15 )
    {
      if ( a1 >= 0 )
        return (unsigned __int16)(a1 >> v4);
      else
        return (unsigned __int16)~(~a1 >> v4);
    }
    else
    {
      return (unsigned __int16)((a1 >= 0) - 1);
    }
  }
}
// 10005183: conditional instruction was optimized away because dx.2<0
// 10009650: using guessed type int dword_10009650;

//----- (10005AF9) --------------------------------------------------------
void sub_10005AF9()
{
  void (**i)(void); // esi

  for ( i = dword_10006778; i < dword_10006778; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 10006778: using guessed type void (*dword_10006778[2])(void);

//----- (10005B19) --------------------------------------------------------
void __cdecl sub_10005B19()
{
  void (**i)(void); // esi

  for ( i = dword_10006780; i < dword_10006780; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 10006780: using guessed type void (*dword_10006780[2])(void);

//----- (10005B46) --------------------------------------------------------
void __cdecl sub_10005B46()
{
  _clean_type_info_names_internal(&unk_10009644);
}
// 10005BEE: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

// nfuncs=67 queued=33 decompiled=33 lumina nreq=0 worse=0 better=0
// ALL OK, 33 function(s) have been successfully decompiled
